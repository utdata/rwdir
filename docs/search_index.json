[["index.html", "Reporting with Data in R About this book A word from Prof. McDonald Tips on the book style About the authors License Other resources", " Reporting with Data in R Christian McDonald and Jo Lukito 2022-02-26 About this book NOTE: This book is under constant rewrite, including a revision for the Spring 2022 semester. The most recent full version is v1 from Fall 2021. Reporting with Data in R is a series of lessons and instructions used for courses in the School of Journalism and Media, Moody College of Communication at the University of Texas at Austin. Assistant Professor Jo Lukito joins Assistant Professor of Practice Christian McDonald in teaching sections of the Reporting with Data for Spring 2022. This means the book is morphing from the voice of a single author and that process might get confusing at times. In addition, Prof. McDonald uses a Mac and Prof. Lukito uses a PC, so keyboard commands and screenshot examples may flip back and forth. We’ll try to note the author and platform at the beginning of each chapter. This work is written in bookdown and the source is available on Github. A word from Prof. McDonald I’m a strong proponent of what I call Scripted Journalism, a method of committing data-centric journalism in a programmatic, repeatable and transparent way. There are a myriad of programming languages that further this, including Python (pandas using Jupyter) and JavaScript (Observable), but we’ll be using R, RMarkdown and RStudio. R is a super powerful, open-source programming language for data that is deep with features and an awesome community of users who build upon it. No matter the challenge before you in your data storytelling, there is probably a package available to help you solve that challenge. Probably more than one. There is always more than one way to do things in R. This book is a Tidyverse-oriented, opinionated collection of lessons intended to teach students new to programming and R for the expressed act of committing journalism. As a beginner course, I strive to make it as simple as possible, which means I may not go into detail about alternative (and possibly better) ways to accomplish tasks in favor of staying in the Tidyverse and reducing options to simplify understanding. Tips on the book style We will try to be consistent in the way we write documentation and lessons. But we are human, so sometimes we break our own rules, but in general keep the following in mind. Things to do Things to DO are in ordered lists: Do this thing. Then do this thing. Explanations are usually in text, like this very paragraph. Sometimes details will be explained in lists: This is the first thing I want you to know. This is the second. You don’t have to DO these things, just know about them. Notes, some important We will use the blockquote syntax to set off a less important aside: Markdown was developed by JOHN GRUBER, as outlined on his Daring Fireball blog. But sometimes those asides are important. We usually indicate that: IMPORTANT: You really should learn how to use Rmarkdown as you will use it the whole semester, and hopefully for the rest of your life. Copy code blocks When you see R code in the instructions, you can roll your cursor over the right-corner and click on the copy icon to copy the code to your clipboard: Copy to clipboard You can then paste the code inside your R chunk. That said, typing code yourself has many, many benefits. You learn better when you type yourself, make mistakes and have to fix them. We encourage you to always type short code snippets. Leave the copying to long ones. About the authors Christian McDonald I’m a career journalist who most recently served as Data and Projects Editor at the Austin American-Statesman before joining the University of Texas at Austin faculty full-time in Fall 2018 as an assistant professor of practice. I’ve taught data-related course at UT since 2013. I also serve as the Innovation Director of the DMN Journalism Innovation Endowment. The UT Data Github: utdata Twitter: crit Email: christian.mcdonald@utexas.edu Jo Lukito I’m an aspiring-journalist-turned-academic who studies journalism and digital media. To make a long story short (tl;dr): I trained to be a journalist as an undergraduate student, but just fell in love with researching and supporting journalism. I completed my Ph.D in 2020, and my dissertation focused on international trade reporting (which relies on plenty o’ data). I also do a ton of social media research (especially in politics and disinformation), so if you’re interested in the social media beat, I’m your gal! Prof. Jo Lukito’s git: jlukito Twitter: JosephineLukito Email: jlukito@utexas.edu Website: https://www.jlukito.com/ License This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. Let’s just say this is free on the internet. We don’t make any money from it and you shouldn’t either. Other resources This text stands upon the shoulders of giants and by design does not cover all aspects of using R. Here are some other useful books, tutorials and sites dedicated to R. There are other task-specific tutorials and articles sprinkled throughout the book in the Resources section of select chapters. R for Data Science by Hadley Wickham and Garrett Grolemund. The Tidyverse site, which has tons of documentation and help. The RStudio Cheatsheets. R Graphics Cookbook The R Graph Gallery another place to see examples. Practical R for Journalism by Sharon Machlis, an editor with PC World and related publications. Sharon is a longtime proponent of using R in journalism. Sports Data Analysis and Visualization and Data Journalism with R and the Tidyverse by Matt Waite, a professor at the University of Nebraska-Lincoln. R for Journalists site by Andrew Tran, a reporter at the Washington Post. A series of videos and tutorials on using R in a journalism setting. "],["install.html", "Chapter 1 Install Party 1.1 Mac vs PC 1.2 Installing R 1.3 Installing RStudio 1.4 Class project folder", " Chapter 1 Install Party This chapter was written by Prof. McDonald using macOS. Let’s get this party started. 1.1 Mac vs PC We’re a big fan of using keyboard commands to do operations in any program, but Prof. McDonald references this from a Mac perspective and Prof. Lukito references this from a PC perspective. So if we say use Cmd+S or Command+S to save, that translates to Cntl+S or Control+S on a PC. Importantly, Cmd (for Mac) and Cntl (for PC) are fairly synonymous, but there may be other differences. Usually, it’s easy to figure the translation out by looking at menu items in RStudio to figure out the Mac/PC command. As we said, Prof. McDonald uses a Mac and Prof. Lukito uses a PC, so we’ll be able to troubleshoot it regardless of the operating system that you use! We will try to note that at the top of a chapter. We will install R and RStudio. It might take some time depending on your Internet connection. If you are doing this on your own you might follow this tutorial. But below you’ll find the basic steps. 1.2 Installing R Our first task is to install the R programming language onto your computer. Go to the https://cloud.r-project.org/. Click on the link for your operating system. The following steps will differ slightly based on your operating system. For Macs, you want the “latest package” unless you have an “M1” Mac (Nov. 2020 or newer), in which case choose the arm64.pkg version. For Windows, you want the “base” package. You’ll need to decide whether you want the 32- or 64-bit version. (Unless you’ve got a pretty old system, chances are you’ll want 64-bit.) This should be pretty self explanatory: once you download the installation file, you should be able to run it on your respective computers to install R. You’ll never “launch” R as a program in a traditional sense, but you need it on your computers (it’s mostly so that the computer can recognize R as a “language”). In all situations (in this class, and beyond), we’ll use RStudio, which is next. 1.3 Installing RStudio RStudio is an “integrated development environment” – or IDE – for programming in R. Basically, it’s the program you will use when doing work for this class. Go to https://www.rstudio.com/download. Scroll down to the versions and find RStudio Desktop and click on the Download button. It should take you down the page to the version you need for your computer. Install it. Should be like installing any other program on your computer. 1.3.1 Getting “Git” errors on Macs If later during package installation you get errors that mention “git” or “xcode-select” then reach out to your instructor. We’ll likely have you install Homebrew and git. 1.4 Class project folder To keep things consistent and help with troubleshooting, We recommend that you save your work in the same location all the time. On both Mac and Windows, every user has a “Documents” folder. Open that folder. (If you don’t know where it is, ask us to help you find it.) Create a new folder called “rwd.” Use all lowercase letters. When we create new “Projects,” I want you to always save them in the Documents/rwd folder. This just keeps us all on the same page. "],["intro.html", "Chapter 2 Introduction to R 2.1 RStudio tour 2.2 Updating preferences 2.3 Starting a new Project 2.4 Using R Notebooks 2.5 Turning in our projects", " Chapter 2 Introduction to R This chapter was written by Prof. McDonald using macOS, with edits by Prof. Lukito 2.1 RStudio tour When you launch RStudio, you’ll get a screen that looks like this: RStudio launch screen 2.2 Updating preferences There is a preference in RStudio that I would like you to change. By default, the program wants to save a the state of your work (all the variables and such) when you close a project, but that is not good practice. We’ll change that. Go to the RStudio menu and choose Preferences Under the General tab, uncheck the first four boxes. On the option “Save Workspace to .Rdata on exit,” change that to Never. Click OK to close the box. RStudio preferences 2.3 Starting a new Project When we work in RStudio, we will create “Projects” to hold all the files related to one another. This sets the “working directory,” which is a sort of home base for the project. Click on the second button that has a green +R sign. That brings up a box to create the project with several options. You want New Directory (unless you already have a Project directory, which you don’t for this.) For Project Type, choose New Project. Next, for the Directory name, choose a new name for your project folder. For this project, use “firstname-first-project” but use YOUR firstname. For the subdirectory, you want to use the Browse button to find your new rwd folder we created earlier. I want you to be anal about naming your folders. It’s a good programming habit. Use lowercase characters. Don’t use spaces. Use dashes. For this class, start with your first name. Rstudio project name, directory When you hit Create Project, your RStudio window will refresh and you’ll see the yourfirstname-first-project.Rproj file in your Files list. 2.4 Using R Notebooks For this class, we will almost always use RNotebooks. This format allows us to write text in between our blocks of code. The text is written in a language called RMarkdown, a juiced-up version of the common documentation syntax used by programmers, Markdown. We’ll learn that in a moment. 2.4.1 Create your first notebook Click on the button at the top-left of RStudio that has just the green + sign. Choose the item R Notebook. This will open a new file with some boilerplate R Markdown code. It serves as an example, explanation and template all in one. At the top between the --- marks, is the metadata. This is written using YAML, and what is inside are commands for the R Notebook. Don’t sweat the YAML syntax too much right now, as we won’t be editing it often. Next, you’ll see a couple of paragraphs of text that describes how to use an RNotebook. It is written in RMarkdown, and has some inline links and bold commands, which you will learn, Then you will see an R code chunk that looks like the figure below. R code chunk Let’s take a closer look at this: The three back tick characters (the key found at the top left on your keyboard) followed by the {r} indicate that this is a chunk of R code. The last three back ticks say the code chunk is over. The {r} bit can have some parameters added to it. We’ll get into that later. The line plot(cars) is R programming code. We’ll see what those commands do in a bit. The green right-arrow to the far right is a play button to run the code that is inside the chunk. The green down-arrow and bar to the left of that runs all the code in the Notebook up to that point. That is useful as you make changes in your code and want to rerun what is above the chunk in question. 2.4.2 Save the .Rmd file Do Cmd+S (ctrl+s for a PC) or hit the floppy disk icon to save the file. It will ask you what you want to name this file. Call it 01-first-file.Rmd. When you do this, you may see another new file created in your Files directory. It’s the pretty version of the notebook which we’ll see in a minute. In the metadata portion of the file, give your notebook a better title. Replace “R Notebook” in the title: \"R Notebook\" code to be “Christian’s first notebook,” but use your name. 2.4.3 Run the notebook There is only one chunk to run in this notebook, so: Click on the green right-arrow to run the code. The keyboard command (from somewhere within the chunk) is Cmd+Shift+Return. You should get something like this: Cars plot What you’ve done here is create a plot chart of a piece of sample data that is already inside R. (FWIW, It is the speed of cars and the distances taken to stop. Note that the data were recorded in the 1920s.) But that wasn’t a whole lot of code to see there is a relationship with speed vs stopping distance, eh? This is a “base R” plot. We’ll be using the tidyverse ggplot methods later in the semester. 2.4.4 A note about RMarkdown We always want to annotate our code to explain what we are doing. To do that, we use a syntax called RMarkdown, which is an R-specific version of Markdown. We use this syntax because it both makes sense when you’re typing up your code and because it makes a very pretty version in HTML when we “knit” our project. You can see how it to write RMarkdown here. Interesting tidbit: you can create slidedecks, websites, and handouts using RMarkdown, so it is useful in a lot of different ways. This entire book is written in RMarkdown. Here is an example: ## My dating age The following section details the [socially-acceptable maximum age of anyone you should date](https://www.psychologytoday.com/us/blog/meet-catch-and-keep/201405/who-is-too-young-or-too-old-you-date). The math works like this: - Take your age - subtract 7 - Double the result The ## line is a headline. Add more ### and you get a smaller headline, like subheads. There is a full blank return between each element, including paragraphs of text. In the first paragraph we have embedded a hyperlink. We put the words we want to show inside square brackets and the URL in parenthesis DIRECTLY after the closing square bracket: [words to link](https://the_url.org). The - at the beginning of a line creates a bullet list. (You can also use *). Those lines need to be one after another without blank lines. Go ahead and copy the code above and add it as text in the notebook so you can see it works later. 2.4.5 Adding new code chunks The text after the chart describes how to insert a new code chunk. Let’s do that. Add a couple of returns before the paragraph of text about code chunks. Use the keys Cmd+Option+i to add the chunk. Your cursor will be inserted into the middle of the chunk. Type in this code in the space provided: # update 55 to your age age &lt;- 55 (age - 7) * 2 ## [1] 96 Change for “55” to your real age. With your cursor somewhere in the code block, use the key command Cmd+Shift+Return, which is the key command to RUN ALL LINES of code chunk. NOTE: To run an individual line, use Cmd+Return while on that line. Congratulations! The answer given at the bottom of that code chunk is the socially-acceptable maximum age of anyone you should date. Throwing aside whether the formula is sound, let’s break down the code. # update 55 to your age is a comment. It’s a way to explain what is happening in the code without being considered part of the code. We create comments by starting with #. You can also add a comment at the end of a line. age &lt;- 55 is assigning a number (55) to an R object/variable called (age). A variable is a placeholder. It can hold numbers, text or even groups of numbers. Variables are key to programming because they allow you to change a value as you go along. The next part is simple math: (age - 7) * 2 takes the value of age and subtracts 7, then multiplies by 2. When you run it, you get the result of the math equazion, [1] 95 in my case. That means there was one observation, and the value was “96.” For the record, my wife is much younger than that. Now you can play with the number assigned to the age variable to test out different ages. Do that. 2.4.6 Practice adding code chunks Now, on your own, add a similar section that calculates the minimum age of someone you should date, but using the formula (age / 2) + 7. Add a RMarkdown headline and text describing what you are doing. Create a code chunk that that calculates the formula based on your age. Include a comment within the code block. 2.4.7 Preview the report The rest of the boilerplate text here describes how you can Preview and Knit a notebook. Let’s do that now. Press Cmd+Shift+K to open a Preview. This will open a new window and show you the “pretty” notebook that we are building. Preview is a little different than Knit, which runs all the code, then creates the new knitted HTML document. It’s Knit to HMTL that you’ll want to do before turning in your assignments. That is explained below. 2.4.8 The toolbar One last thing to point out before we turn this in: The toolbar that runs across the top of the R Notebook file window. The image below explains some of the more useful tools, but you REALLY should learn and use keyboard commands when they are available. R Notebook toolbar 2.4.9 Knit the final workbook Save your File with Cmd+S. Click on the dropdown next to the Run menu item and choose Restart R and Run All Chunks. We do this to make sure everything still works. Use the Knit button in the toolbar to choose Knit to HTML. This will open your knitted file. Isn’t it pretty? 2.5 Turning in our projects If you now look in your Files pane, you’ll see you have four files in our project. (Note the only one you actually edited was the .Rmd file.) Files list The best way to turn in all of those files into Canvas is to compress them into a single .zip file that you can upload to the assignment. In your computer’s Finder, open the Documents/rwd folder. Follow the directions for your operating system linked below to create a compressed version of your yourname-final-project folder. Compress files on a Mac. Compress flies on Windows. Upload the resulting .zip file to the assignment for this week in Canvas. If you find you make changes to your R files after you’ve zipped your folder, you’ll need to delete the zip file and compress it again. Because we are building “repeatable” code, I’ll be able to download your .zip files, uncompress them, and the re-run them to get the same results. Well done! You’ve completed the first level and earned the Beginner badge. "],["counts-import.html", "Chapter 3 Summarize with count - import 3.1 Learning goals of this lesson 3.2 Basic steps of this lesson 3.3 Create a new project 3.4 The Billboard Hot 100 3.5 Import the data 3.6 Assign our import to an R object 3.7 Cleaning data 3.8 Cleaning column names 3.9 Fixing the date 3.10 Arrange the data 3.11 Selecting columns 3.12 Exporting data 3.13 Naming chunks 3.14 Knit your page 3.15 Review of what we’ve learned so far 3.16 What’s next", " Chapter 3 Summarize with count - import “If you’re doing data analysis every day, the time it takes to learn a programming language pays off pretty quickly because you can automate more and more of what you do.” –Hadley Wickham, chief scientist at RStudio Note: This lesson was written by Prof. McDonald and I use macOS. 3.1 Learning goals of this lesson Practice organized project setup. Learn a little about data types available to R. Learn about R packages, how to install and import them. Learn how to download and import CSV files using the readr package. Introduce the Tibble/Data Frame. Introduce the tidyverse %&gt;%. Learn how to modify data types (date) and select() columns. We’ll be exploring the Billboard Hot 100 charts along the way. Eventually you’ll find the answers to a bunch of questions in this data and write about it. 3.2 Basic steps of this lesson Before we get into our storytelling, we have to set up our project, get our data and make sure it is in good shape for analysis. This is pretty standard for any new project. Here are the major steps we’ll cover in detail for this lesson (and many more to come): Create your project structure Find the data and (usually) get onto on your computer Import the data into your project Clean up column names and data types Export cleaned data for later analysis 3.3 Create a new project You’ve done this once already in Chapter 2 so you got this! But here are the basic steps for you to follow: Launch RStudio Make sure you don’t have an existing project open. Use File &gt; Close project if you do. Use the +R button to create a New Project in a New Directory. Name the project yourfirstname-billboard and put it in your ~/Documents/rwd folder. Use the + button and use R Notebook to start a new notebook. Change the title to “Billboard Hot 100 Import.” Delete the other boilerplate text. Save the file as 01-import.Rmd. We named this notebook starting with 01- because we will eventually end up with multiple notebooks and we want to know the order to run them. 3.3.1 Describe the goals of the notebook We’ll add our first bit of RMarkdown just after the meta data to explain what we are doing. Add this text to your notebook: ## Goals of this notebook Steps to prepare our data: - Download the data - Import into R - Clean up data types and columns - Export for next notebook We want to start each notebook with a list like this so our future selves and others know what the heck we are trying to accomplish. We will also write text like this for each new “section” or goal in the notebook. 3.3.2 The R Package environment We have to back up from the step-by-step nature of this lesson and talk a little about the R programming language. R is an open-source language, which means that other programmers can contribute to how it works. It is what makes R beautiful. What happens is developers will find it difficult to do a certain task, so they will write an R “Package” of code that helps them with that task. They share that code with the community, and suddenly the R garage has an “ultimate set of tools” that would make Spicoli’s dad proud. One set of these tools is the tidyverse introduced by Hadley Wickham and his team at RStudio. It’s a set of R packages for data science that work together in similar ways. Prof. Lukito and I are worshipers of the tidyverse worldview and we’ll use these tools extensively. While not required reading, I highly recommend Wickham’s book R for data science, which is free. There are also a series of useful tidyverse cheatsheets that can help you as you use the packages and functions from the tidyverse. We’ll refer to these throughout the course. 3.3.3 Installing and using packages There are two steps to using an R package: Install the package using install.packages(\"package_name\"). You only have to do this once for each computer, so I usually do it using the R Console instead of in an R Notebook. Include the library using library(package_name). This has to be done for each R Notebook or script that uses it, so it is usually one of the first things you’ll see in a notebook. Note that you have to use “quotes” around the package name when you are installing, but you DON’T use quotes when you load the library. We’re going to install several packages we will use in this project. To do this, we are going to use the Console, which we haven’t talked about much yet. The Console and Terminal Use the image above to orient yourself to the R Console and Terminal. In the Console, type in: install.packages(&quot;tidyverse&quot;) As you type into the Console, you’ll see some type-assist hints on what you need. You can use the arrow keys to select one and hit the tab key to complete that command, then enter the values you need. If it asks you to install “from source,” type Yes and hit return. You’ll see a bunch of response in the Console. When you install the “tidyverse” package you actually get eight individual packages. You’ll see references to “dplyr” even some functions referenced as dplyr::filter() but they are all part of the tidyverse. You can explore the list at tidyverse.org but know there are other packages from the same folks that we use and load separately. We need two other packages as well, so also do: install.packages(&quot;janitor&quot;) install.packages(&quot;lubridate&quot;) We’ll use janitor to clean up our data column names, among other things. A good reference to learn more is the janitor vignette. We’ll use lubridate to fix some dates, which are a special complicated thing in programming. While Lubridate is part of the tidyverse universe, we have to install and load it separately. You only have to install the packages once on your computer (though you have to load the libraries into each new notebook, which is explained below). 3.3.4 Load the libraries Next, we’re going to tell our R Notebook to use these three libraries. After the metadata at the top of your notebook, use Cmd+option+i to insert an R code chunk. In that chunk, type in the three libraries and run the code block with Cmd+Shift+Return. This is the code you need: library(tidyverse) library(janitor) library(lubridate) Your output will look something like this: Libraries imported Don’t sweat the Conflicts listed there. It’s all good. 3.3.5 Create a directory for your data Next we are going to create some folders in our project folder. We’ll use some standard names for consistency. The first folder is called data-raw. We are creating this folder because we want to keep a pristine version of our original data that we never change or overwrite. This is a core data journalism commandment: Thou shalt not change original data. In your Files pane at the bottom-right of Rstudio, there is a New Folder icon. Click on the New Folder icon. Name your new folder data-raw. This is where we’ll put raw data. We never write data to this folder. Also create another new folder called data-processed. This is were we will write data. We separate them so we don’t accidentally overwrite raw data. Once you’ve done that, they should show up in the file explorer in the Files pane. Click the refresh button if you don’t see them. (The circlish thing at top right of the screenshot below. You might have to widen the pane to see it.) Directory made Your .Rproj file name is likely a different name (and that is OK) and you can ignore the .gitignore I have there. 3.3.6 About data sources Depending on the data source, importing can be brilliantly easy or a major pain in the rear. It all depends on how well-formatted it is. In this class, we will primarily use data stored as CSVs (Comma Separated Value), Excel files and APIs (Application Programming Interface). CSVs are a kind of lowest-common-denominator for data. Most any database or program can import or export them. It’s just text with a , or some other separator between each value. Excel files are good, but can get messy when humans get involved. They often have multiple header rows, columns used in multiple ways, notes added, etc. Just know you might have to clean them up before or after importing them. APIs are systems designed to respond to programming. In the data world, we often use the APIs by writing a query to ask a system to return a selection of data. By definition, the data is well structured. You can often determine the file type of the output as part of the API call, including … JSON (or JavaScript Object Notation) is the data format preferred by JavaScript. R can read it, too. It is often the output format of APIs, and prevalent enough that you need to understand how it works. We’ll get into that later in semester. Don’t get me wrong … there are plenty of other data types and connections available through R, but those are the ones we’ll deal with most in this book. While our data may be found on the internet in a data portal or through an API, we typically want to download a copy of it to our own machine for safe keeping. We will do that here, but let’s talk about the data first. 3.4 The Billboard Hot 100 The Billboard Hot 100 singles charts has been the music industry’s standard record chart since its inception on 8/2/1958. The rankings, published by Billboard Media, are currently based on sales (physical and digital), radio play, and online streaming. The methods and policies of the chart have changed over time. The data we will use here is a combination of data collected by Kaggle user Dhruvil Dave, along with some scraping and merging by Prof. McDonald. It is stored on the code sharing website Github for safe keeping. When you write about this data (and you will), you should source it as the Billboard Hot 100 from Billboard Media, since that is where it originally came from and they are the “owner” of the data. 3.4.1 Data dictionary Take a look at the current chart. Our data contains many (but not quite all) of the elements you see there. Each row of data (or observation as they are known in R) represents a song and the corresponding position on that week’s chart. Included in each row are the following columns (a.k.a. variables): CHART WEEK: The release date of the chart THIS WEEK: The current ranking as of the chart date SONG: The song title PERFORMER: The performer of the song LAST WEEK: The ranking on the previous week’s chart PEAK POS.: The peak rank the song has reached as of the chart date WKS ON CHART: The number of weeks the song has appeared as of the chart date 3.4.2 Let’s download our data Since this data is stored on Github, we can reference it through a URL and download it into our project. Since this is a new “section” of our R Notebook, we’ll note what we are doing and why in Markdown. Add a Markdown headline ## Downloading data and on a new line text that indicates you are downloading data. You would typically include a link and explain what it is, etc, often linking to the original source. Create an R chunk and include the following (hint: use the copy icon at the top right): download.file(&quot;https://github.com/utdata/rwd-billboard-data/blob/main/data-out/hot100_archive.csv?raw=true&quot;, &quot;data-raw/hot100_archive.csv&quot;) This download.file function takes at least two arguments: The URL of the file you are downloading The path and name of where you want to save it. Note those two arguments are in quotes. The path includes the folder and file name as it relates to where your R Notebook is. In this case we need to go inside the data-raw folder and then name the file: data-raw/hot100_archive.csv. When you run this, it should save the file and then give you output similar to this: trying URL &#39;https://github.com/utdata/rwd-billboard-data/blob/main/data-out/hot100_archive.csv?raw=true&#39; Content type &#39;text/plain; charset=utf-8&#39; length 17960724 bytes (17.1 MB) ================================================== downloaded 17.1 MB That’s not a small file at 17 MB and 300,000 rows, but it’s not a huge one, either. 3.4.3 Consider commenting the download Now that we’ve downloaded the data to our computer, we don’t need to run this line of code again unless we know our data source has updated. We can “comment” the code to preserve it but keep it from running again if we re-run our notebook (and we will). Put a # at the beginning of the line with the download.file() function. In Markdown above it, add a note to your future self that you commented the download for now. Adding comments in programming is a common thing and every programming language has a way to do it. It is a way for the programmer to write notes to their future self, colleagues or — like in this case — comment out some code that you want to keep, but don’t want to execute when the program is run. In R, anything following one ore more hashes # inside a code chunk will be a comment: The text is there, but it won’t be executed as code. (Yes, this is a bit confusing since #’s are used for headlines in the Markdown parts of the file.) In R Notebooks we put a most of our “explaining” text in Markdown outside of code chunks … it’s one of the reasons we like using R Notebooks. But sometimes it makes more sense to explain something right where the code is being executed, so that is where the code comments come in. 3.5 Import the data Now that we have the data on our machine, let’s import it into our notebook so we can see it. Since we are doing a new thing, we should note that with a Markdown headline and text. Add a Markdown headline: ## Import data Add some text to explain that we are importing the Billboard Hot 100 data. After your description, add a new code chunk (Cmd+Option+i). We’ll be using the read_csv() function from the tidyverse readr package, which is different from read.csv that comes with base R. read_csv() is mo betta. Inside the function we put in the path to our data, inside quotes. If you start typing in that path and hit tab, it will complete the path. (Easier to show than explain). Add the following code into your chunk and run it. read_csv(&quot;data-raw/hot100_archive.csv&quot;) Note the path is in quotes. You get two results printed to your screen. The first result called “R Console” shows what columns were imported and the data types. It’s important to review these to make sure things happened the way that expected. In this case it noted which columns came in as text (chr), or numbers (dbl). Note: Red colored text in this output is NOT an indication of a problem. RConsole output The second result spec_tbl_df prints out the data like a table. The data object is a tibble, which is a fancy tidyverse version of a “data frame.” I will use the term tibble and data frame interchangably. Think of tibbles and data frames like a well-structured spreadsheet. They are organized rows of data (called observations) with columns (called variables) where every column is a specific data type. Data output When we look at the data output into RStudio, there are several things to note: Below each column name is an indication of the data type. This is important. You can use the arrow icon on the right to page through the additional columns. You can use the paging numbers and controls at the bottom to page through the rows of data. The number of rows and columns is displayed. Of special note here, we have only printed this data to the screen. We have not saved it in any way, but that is next. 3.6 Assign our import to an R object As of right now, we’ve only printed the data to our screen. We haven’t “saved” it at all. Next we need to assign it to an R object so it can be named thing in our project environment and we can reuse it. We don’t want to re-import the data every time we use the data. The syntax to create an object in R can seem weird at first, but the convention is to name the object first, then insert stuff into it. So, to create an object, the structure is this: # this is pseudo code. Don&#39;t put it in your notebook. new_object &lt;- stuff_going_into_object Think of it like this: You must have a bucket before you can fill it with water. We “name” the bucket, then fill it with data. Let’s make a object called hot100 and fill it with our imported tibble. Edit your existing code chunk to look like this. You can add the &lt;- by using Option+- as in holding down the Option key and then pressing the hyphen: hot100 &lt;- read_csv(&quot;data-raw/hot100_archive.csv&quot;) Run that chunk and several things happen: We no longer see the result of the data in the notebook because we created an object instead of printing it. In the Environment tab at the top-right of RStudio, you’ll see the hot100 object listed. Click on the blue play button next to hot100 and it will expand to show you a summary of the columns. Click on the name hot100 and it will open a “View” of the data in another window, so you can look at it in spreadsheet form. You can even sort and filter it. Once you’ve looked at the data, close the data view with the little x next to the tab name. 3.6.1 Print a peek to your R Notebook Since we can’t see the data after we assign it, let’s print the object to our notebook so we can refer to it. Edit your import chunk to add the last two lines of this, including the one with the #: hot100 &lt;- read_csv(&quot;data-raw/hot100_archive.csv&quot;) # peek at the data hot100 You can use the green play button at the right of the chunk, or preferrably have your cursor inside the chunk and do Cmd+Shift+Return to run all lines. (Cmd+Return runs only the current line.) This prints your saved object to your notebook. Note I added a little comment with the # inside the code chunk. I’m just noting to my future self why I’m doing this. 3.6.2 Glimpse the data There is another way to peek at the data that I prefer because it is more compact and shows you all the columns and data examples without scrolling: glimpse(). In your existing chunk, edit the last line to add the glimpse() function as noted below. I’m showing the return here as well. Afterward I’ll explain the pipe: %&gt;%. hot100 &lt;- read_csv(&quot;data-raw/hot100_archive.csv&quot;) # peek at the data hot100 %&gt;% glimpse() ## Rows: 330,787 ## Columns: 7 ## $ `CHART WEEK` &lt;chr&gt; &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11… ## $ `THIS WEEK` &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, … ## $ SONG &lt;chr&gt; &quot;Easy On Me&quot;, &quot;Stay&quot;, &quot;Industry Baby&quot;, &quot;Fancy Like&quot;, &quot;B… ## $ PERFORMER &lt;chr&gt; &quot;Adele&quot;, &quot;The Kid LAROI &amp; Justin Bieber&quot;, &quot;Lil Nas X &amp; … ## $ `LAST WEEK` &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 9, 7, 11, 8, 12, 10, 14, 15, 21, 16, … ## $ `PEAK POS.` &lt;dbl&gt; 1, 1, 1, 3, 2, 1, 7, 1, 9, 2, 9, 3, 12, 14, 15, 11, 1, … ## $ `WKS ON CHART` &lt;dbl&gt; 3, 16, 14, 19, 18, 8, 7, 24, 20, 56, 17, 29, 41, 18, 8,… The glimpse shows there are 300,000+ rows and 7 columns in our data. Each column is then listed out with its data type and the first several values in that column. 3.6.3 About the pipe %&gt;% We need to break down this code a little: hot100 %&gt;% glimpse(). We are starting with the object hot100, but then we follow it with %&gt;%, which is called a pipe. The pipe is a tidyverse tool that allows us to take the results of an object or function and pass them into another function. Think of it like a sentence that says “AND THEN” the next thing. It might look like there are no arguments inside glimpse(), but what we are actually doing is passing the hot100 tibble into it. You can’t start a new line with a pipe. If you are breaking your code into multiple lines, then the %&gt;% needs to be at the end and the next line should be indented so there is a visual clue it is related to line above it, like this: hot100 %&gt;% glimpse() IMPORTANT: There is a keyboard command for the pipe %&gt;%: Cmd+Shift+m. Learn that one! 3.7 Cleaning data This “Checking Your Data” section of this DataCamp tutorial has a good outline of what makes good data, but in general it should: Have a single header row with well-formed column names. One column name for each column. No merged cells. Short names are better than long ones. Spaces in names make them harder to work with. Use and _ or . between words. I prefer _ and lowercase text. Remove notes or comments from the files. Each column should have the same kind of data: numbers vs words, etc. Each row should be a single thing called an “observation.” The columns should describe attributes of that observation. Data rarely comes perfect and that can cause challenges when importing and cleaning data. We’ll face some of those challenges here. In our case our columns names could use help, and our field CHART WEEK is not really a date, but text characters. We’ll tackle those issues next. 3.8 Cleaning column names So, given those notes above, we should clean up our column names. This is why we have included the janitor package, which includes a neat function called clean_names() Edit the first line of your chunk to add a pipe and the clean_names function: %&gt;% clean_names() hot100 &lt;- read_csv(&quot;data-raw/hot100_archive.csv&quot;) %&gt;% clean_names() # peek at the data hot100 %&gt;% glimpse() ## Rows: 330,787 ## Columns: 7 ## $ chart_week &lt;chr&gt; &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6… ## $ this_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17… ## $ song &lt;chr&gt; &quot;Easy On Me&quot;, &quot;Stay&quot;, &quot;Industry Baby&quot;, &quot;Fancy Like&quot;, &quot;Bad… ## $ performer &lt;chr&gt; &quot;Adele&quot;, &quot;The Kid LAROI &amp; Justin Bieber&quot;, &quot;Lil Nas X &amp; Ja… ## $ last_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 9, 7, 11, 8, 12, 10, 14, 15, 21, 16, 17… ## $ peak_pos &lt;dbl&gt; 1, 1, 1, 3, 2, 1, 7, 1, 9, 2, 9, 3, 12, 14, 15, 11, 1, 15… ## $ wks_on_chart &lt;dbl&gt; 3, 16, 14, 19, 18, 8, 7, 24, 20, 56, 17, 29, 41, 18, 8, 1… This function has cleaned up your names, making them all lowercase and using _ instead of periods between words. Believe me when I say this is helpful when you are writing code. It makes type-assist work better and you can now double-click on a column name to select all of it and copy and paste somewhere else. When you have spaces or dashes in an object you can’t double-click on it and get all of it. 3.9 Fixing the date Dates in programming are a tricky datatype because they are represented essentially as the number of seconds before/after January 1, 1970. Yes, that’s crazy, but it is also cool because that allows us to do math on them. So, to use our chart_week properly in R we need to convert it from the text into a real date datatype. (You can read more about why dates are tough in programming here.) Converting text into dates can be difficult, but the tidyverse universe has a package called lubridate to ease the friction. (Get it?). Since we are doing something new, we want to start a new section in our notebook and explain what we are doing. Add a headline: ## Fix our dates. Add some text that you are using lubridate to create a new column with a real date. Add a new code chunk. Remember Cmd+Option+i will do that. We will be changing or creating our data, so we will create a new object to store it in. We do this so we can go back and reference the unchanged data if we need to. Because of this, we’ll set up a chunk of code that allows us to peek at what is happening while we write our code. We’ll do this often. Add the following inside your code chunk. # part we will build upon hot100_date &lt;- hot100 # peek at the result hot100_date %&gt;% glimpse() ## Rows: 330,787 ## Columns: 7 ## $ chart_week &lt;chr&gt; &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6… ## $ this_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17… ## $ song &lt;chr&gt; &quot;Easy On Me&quot;, &quot;Stay&quot;, &quot;Industry Baby&quot;, &quot;Fancy Like&quot;, &quot;Bad… ## $ performer &lt;chr&gt; &quot;Adele&quot;, &quot;The Kid LAROI &amp; Justin Bieber&quot;, &quot;Lil Nas X &amp; Ja… ## $ last_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 9, 7, 11, 8, 12, 10, 14, 15, 21, 16, 17… ## $ peak_pos &lt;dbl&gt; 1, 1, 1, 3, 2, 1, 7, 1, 9, 2, 9, 3, 12, 14, 15, 11, 1, 15… ## $ wks_on_chart &lt;dbl&gt; 3, 16, 14, 19, 18, 8, 7, 24, 20, 56, 17, 29, 41, 18, 8, 1… Let’s break this down: I have a comment starting with # to explain the first part of the code We created a new “bucket” called hot100_date and we fill it with our hot100 data. Yes, as of now they are exactly the same. I have a blank line for clarity Then another comment Then we glimpse the new hot100_date object so we can see changes as we work on it. To be clear, we haven’t changed any data yet. We just created a new object like the old object. 3.9.1 Working with mutate() We are going to use the text of our date field chart_week to create a new converted date. We will use the dplyr function mutate() to do this, with some help from lubridate. dplyr is the tidyverse package of functions to manipulate data. We’ll use functions from it a lot. It is loaded with the library(tidyverse) so you don’t have to load it separately. Let’s explain how mutate works first: Mutate changes every value in a column. You can either create a new column or overwrite an existing one. Within the mutate function, we name the new thing first (the bucket first!) and then fill it with the new value. # this is psuedo code. Don&#39;t run it. data %&gt;% mutate( newcol = new_stuff_from_math_or_whatever ) That new value could be arrived at through math or any combination of other functions. In our case, we want to convert our old text-based date to a real date, and then assign it back to the “new” column. A note about my pseudo code above: I strategically used returns to make the code more readable. This code would work the same if it were all on the same line, but writing it this way helps me understand it. RStudio will help you indent properly this as you type. (Easier to show than explain.) Edit your chunk to add the changes below and run it. I implore you to type the changes so you see how RStudio helps you write it. Use tab completion, etc. # part we will build upon hot100_date &lt;- hot100 %&gt;% mutate( chart_date = mdy(chart_week) ) # peek at the result hot100_date %&gt;% glimpse() ## Rows: 330,787 ## Columns: 8 ## $ chart_week &lt;chr&gt; &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6-2021&quot;, &quot;11-6… ## $ this_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17… ## $ song &lt;chr&gt; &quot;Easy On Me&quot;, &quot;Stay&quot;, &quot;Industry Baby&quot;, &quot;Fancy Like&quot;, &quot;Bad… ## $ performer &lt;chr&gt; &quot;Adele&quot;, &quot;The Kid LAROI &amp; Justin Bieber&quot;, &quot;Lil Nas X &amp; Ja… ## $ last_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 9, 7, 11, 8, 12, 10, 14, 15, 21, 16, 17… ## $ peak_pos &lt;dbl&gt; 1, 1, 1, 3, 2, 1, 7, 1, 9, 2, 9, 3, 12, 14, 15, 11, 1, 15… ## $ wks_on_chart &lt;dbl&gt; 3, 16, 14, 19, 18, 8, 7, 24, 20, 56, 17, 29, 41, 18, 8, 1… ## $ chart_date &lt;date&gt; 2021-11-06, 2021-11-06, 2021-11-06, 2021-11-06, 2021-11-… Again, let’s break down what we’ve done: At the end of the first line, we added the pipe %&gt;% because we are taking our hot100 data AND THEN we will mutate it. Next, we start the mutate() function. If you use type assist and tab completion to type this in, your cursor will end up in the middle of the parenthesis. This allows you to then hit your Return key to split it into multiple lines with proper indenting. We do this so we can more clearly see what inside the mutate … where the real action is going on here. It’s also possible to make multiple changes within the same mutate, and putting each one on their own line makes that more clear. Inside the mutate, we first name our new column chart_date and then we set that equal to mdy(chart_week), which is explained next. The mdy() function is part of the lubridate package. Lubridate allows us to parse text and then turn it into a real date if we tell it the order of the date values in the original data. Our original date was something like “07/17/1965.” That is month, followed by day, followed by year. We use the lubridate function mdy() to say that’s the order this text is in, now please convert this into a real date, which properly shows as YYYY-MM-DD. Lubridate is smart enough to figure out if you have / or - between your values in the original text. If your original text is in a different date order, then you look up what lubridate function you need to convert it. I typically use the cheatsheet on the lubridate documentation. You’ll find them in the PARSE DATE-TIMES section. 3.9.2 Check the result! This new chart_date column is added at the END of our data. After doing any kind of mutate you want to check the result to make sure you got the results you expected. This is why we built our code this way with glimpse() so we can see example of our data from both the first and the last column. (We’ll rearrange all the columns in a bit once we are done cleaning everything.) Did your dates convert correctly? 3.10 Arrange the data If you are paying attention to the dates of our rows of data, you’ll notice the first row is from “2021-11-06,” which is not the first date of our data as I described this (that was in 1958) nor the last date (late December of 2021). Let’s sort this data so that the oldest data is at the top. Sorting data is not a particularly difficult concept to grasp, but it is one of the Basic Data Journalism Functions … In R, the sorting function we use is called arrange(). We’ll build our our data and use the pipe%&gt;% to push it into an arrange() function. Inside arrange we’ll give it the columns we wish to sort by. Edit your chunk to the following to add the arrange() function: # part we will build upon hot100_date &lt;- hot100 %&gt;% mutate( chart_date = mdy(chart_week) ) %&gt;% arrange(chart_date, this_week) # peek at the result hot100_date %&gt;% glimpse() ## Rows: 330,787 ## Columns: 8 ## $ chart_week &lt;chr&gt; &quot;8-4-1958&quot;, &quot;8-4-1958&quot;, &quot;8-4-1958&quot;, &quot;8-4-1958&quot;, &quot;8-4-1958… ## $ this_week &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17… ## $ song &lt;chr&gt; &quot;Poor Little Fool&quot;, &quot;Patricia&quot;, &quot;Splish Splash&quot;, &quot;Hard He… ## $ performer &lt;chr&gt; &quot;Ricky Nelson&quot;, &quot;Perez Prado And His Orchestra&quot;, &quot;Bobby D… ## $ last_week &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N… ## $ peak_pos &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17… ## $ wks_on_chart &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ chart_date &lt;date&gt; 1958-08-04, 1958-08-04, 1958-08-04, 1958-08-04, 1958-08-… Now when you look at the glimpse, the first record in the chart_date column is from “1958-08-02” and the first in the this_week is “1,” which is the top of the chart. Just to see this all clearly in table form, we’ll print the top of the table to our screen so we can see it. Add a line of Markdown text in your notebook explaining your are looking at the table. Add a new code chunk and add the following. In case you haven’t noticed yet, the code printout in your notebook is a lot cooler than in this online book. hot100_date %&gt;% head(10) ## # A tibble: 10 × 8 ## chart_week this_week song performer last_week peak_pos wks_on_chart ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 8-4-1958 1 Poor Lit… Ricky Nelson NA 1 1 ## 2 8-4-1958 2 Patricia Perez Prado A… NA 2 1 ## 3 8-4-1958 3 Splish S… Bobby Darin NA 3 1 ## 4 8-4-1958 4 Hard Hea… Elvis Presley… NA 4 1 ## 5 8-4-1958 5 When Kalin Twins NA 5 1 ## 6 8-4-1958 6 Rebel-&#39;r… Duane Eddy Hi… NA 6 1 ## 7 8-4-1958 7 Yakety Y… The Coasters NA 7 1 ## 8 8-4-1958 8 My True … Jack Scott NA 8 1 ## 9 8-4-1958 9 Willie A… The Johnny Ot… NA 9 1 ## 10 8-4-1958 10 Fever Peggy Lee NA 10 1 ## # … with 1 more variable: chart_date &lt;date&gt; This just prints the first 10 lines of the data. Use the arrows to look at the other columns of the data (which you can’t see in the book). Note: It’s OK that the last_week columns has “NA” for those first rows because this is the first week ever for the chart. There was no last_week. 3.10.1 Getting summary stats Printing your data to the notebook can only tell you so much. Yes, you can arrange by different columns to see the maximum and minimum values, but it’s hard to get an overall sense of your data that way when there is 300,000 rows like we have here. Luckily there is a nice function called summary() that is similar to glimpse() that gives you some summary statistics for your columns. Add some Markdown text that you’ll print summary stats of your data. Add a new R chunk and put the following in and run it hot100_date %&gt;% summary() ## chart_week this_week song performer ## Length:330787 Min. : 1.0 Length:330787 Length:330787 ## Class :character 1st Qu.: 26.0 Class :character Class :character ## Mode :character Median : 51.0 Mode :character Mode :character ## Mean : 50.5 ## 3rd Qu.: 76.0 ## Max. :100.0 ## ## last_week peak_pos wks_on_chart chart_date ## Min. : 1.00 Min. : 1.00 Min. : 1.000 Min. :1958-08-04 ## 1st Qu.: 23.00 1st Qu.: 13.00 1st Qu.: 4.000 1st Qu.:1974-06-08 ## Median : 47.00 Median : 38.00 Median : 7.000 Median :1990-04-21 ## Mean : 47.59 Mean : 40.95 Mean : 9.168 Mean :1990-04-17 ## 3rd Qu.: 71.00 3rd Qu.: 65.00 3rd Qu.:13.000 3rd Qu.:2006-02-25 ## Max. :100.00 Max. :100.00 Max. :90.000 Max. :2021-12-25 ## NA&#39;s :32461 These summary statistics can be informative for us. It is probably the easiest way to check what the newest and oldest dates are in your data (see the Min. and Max. returns for chart_date). You get an average (mean) and median for each number, too. You might notice potential problems in your data, like if we had a this_week number higher than “100” (we don’t). 3.11 Selecting columns Now that we have the fixed date column, we don’t need the old chart_week version that is text. We’ll use this opportunity to discuss select(), which is another concept in our Basic Data Journalism Functions series: In R, the workhorse of the select concept is the function called — you guessed it — select(). In short, the function allows us to choose a subset of our columns. We can either list the ones we want to keep or the ones we don’t want. Like a lot of things in R, select() is really easy at its most basic level: List the columns you want to keep. But select() can also be very powerful as you learn more options. There are a bunch of selection helpers like starts_with() and ends_with() and everything(). You can choose ranges with numbers 1:3 or column names col_name1:col_name9, or a combination c(col_nam1, col_name3). You can specify what NOT to keep with the negate symbol ! like this !c(col_nam1, col_name3). You can even rename columns as you select them, which we’ll do below. In our case we will select the columns want to keep, and we’ll rename some as we do. Add a Markdown headline: ## Selecting columns. Explain in text we are dropping the text date column and renaming others. Add the code below and then I’ll explain it. We again are setting this up to create a new object and view the changes. hot100_tight &lt;- hot100_date %&gt;% select( chart_date, # renaming example with new name first current_rank = this_week, song, performer, previous_rank = last_week, peak_rank = peak_pos, wks_on_chart ) hot100_tight %&gt;% glimpse() ## Rows: 330,787 ## Columns: 7 ## $ chart_date &lt;date&gt; 1958-08-04, 1958-08-04, 1958-08-04, 1958-08-04, 1958-08… ## $ current_rank &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… ## $ song &lt;chr&gt; &quot;Poor Little Fool&quot;, &quot;Patricia&quot;, &quot;Splish Splash&quot;, &quot;Hard H… ## $ performer &lt;chr&gt; &quot;Ricky Nelson&quot;, &quot;Perez Prado And His Orchestra&quot;, &quot;Bobby … ## $ previous_rank &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ peak_rank &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… ## $ wks_on_chart &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… Line by line, it goes like this: Name our new object hot100_tight and fill it with the result of hot100_date and then the modifications that follow. We use the select() function to choose our columns to keep, renaming some of them along the way: We start with chart_date which is our real date. We just won’t ever name the text version so we won’t keep it. When we get to our this_week column, we rename it to current_rank. We’re doing this because we’ll rename all the “ranking” columns with something that includes _rank at the end. We’re being (too) clever here so later we can use select(ends_with(\"_rank\")) to get those ranking columns together. Note the R concept of naming the new thing first before filling it. For song and performer we just list them because we want them to come next but we don’t need to change the names at all. For the other columns we rename or not as needed. Lastly, we glimpse the new object to check it. There are other ways to accomplish the same thing, but this works for us. 3.12 Exporting data 3.12.1 Single-notebook philosophy I have a pretty strong opinion that you should be able to freshly open any R Notebook in your project and run it from top to bottom without it breaking. In short, one notebook should not be dependent on running another open notebook. This is why I had you name this notebook 01-import.Rmd with a 01 at the beginning. We’ll number our notebooks in the order they should be run. It’s an indication that before we can use the notebook 02-analysis (next lesson!) that the 01-import.Rmd notebook has to be run first. I use 01- instead of just 1- in case there are more than nine notebooks. I want them to appear in order in my files directory. I’m anal retentive like that, which is a good trait for a data journalist. So we will create an exported file from our first notebook that can be used in the second one. Once we create that file, the second notebook can be opened and run at any time. Why make this so complicated? The answer is consistency. When you follow the same structure with each project, you quickly know how to dive into that project at a later date. If everyone on your team uses the same structure, you can dive into your teammates code because you already know how it is organized. If we separate our importing/cleaning into it’s own file to be used by many other notebooks, we can fix future cleaning problems in ONE place instead of many places. One last example to belabor the point: It can save time. I’ve had import/cleaning notebooks that took 20 minutes to process. Imagine if I had to run that every time I wanted to rebuild my analysis notebook. Instead, the import notebook spits out a clean file that can be imported in a fraction of that time. This was all a long-winded way of saying we are going to export our data now. 3.12.2 Exporting as rds We are able to pass cleaned data between notebooks because of a native R data format called .rds. When we export in this format it saves not only rows and columns, but also the data types. (If we exported as CSV, we would potentially have to re-fix the date or other data types when we imported again.) We will use another readr function called write_rds() to create our file to pass along to the next notebook, saving the data into the data-processed folder we created earlier. We are separating it from our data-raw folder because “Thou shalt not change original data” even by accident. By always writing data to this different folder, we hopefully avoid accidentally overwriting our original data. Create a Markdown headline ## Exports and write a description that you are exporting files to .rds. Add a new code chunk and add the following code: hot100_tight %&gt;% write_rds(&quot;data-processed/01-hot100.rds&quot;) So, here we are starting with the hot100_tight tibble that we saved earlier. We then pipe %&gt;% the result of that into a new function write_rds(). In addition to the data, the function needs to know where to save the file, so in quotes we give the path to where and what we want to call the file: \"data-processed/01-hot100.rds\". Remember, we are saving in data-processed because we never export into data-raw. We are naming the file starting with 01- to indicate to our future selves that this output came from our first notebook. We then name it, and use the .rds extension. 3.13 Naming chunks I didn’t want to break our flow of work to explain this earlier*, but I want you to name all your chunks so you can use a nice feature in RStudio to jump up and down your notebook. Let me show you and example of why first. Look at the bottom of your window above the console and you’ll see a dropdown window. Click on that. Here is mine, but yours will be different: RStudio bookmarks You’ll notice that my chunks have names, but yours probably don’t. It’s pretty helpful have these names so you know what the chunk does. You can use this menu to skip up and down the notebook. How to name a chunk? Well, I can’t show you in code because it is not rendered in the book, but here is a picture: Named chunks See where I have {r download}? I named it that because that is what the chunk does. I suggest using a single word or - or _ between words. There are other configurations we can do between the {} here, but that is for another day. Go back through your notebook and name all your chunks. Under the Run menu, choose Restart R and run all chunks. Make sure that your Notebook runs all the way from top to bottom. The order of stuff in the notebook matters and you can make errors as you edit up and down the notebook. You always want to do this before you finish a notebook. * Break the flow … I wrote that and laughed out loud at all the silly asides (like this one) that I throw into intricate documentation. Like if. You are welcome and I’m sorry. 3.14 Knit your page Lastly, I want you to Knit your notebook so you can see the pretty HTML version. Next to the Preview menu in the notebook tool bar, click the little dropdown to see the knitting options. Choose Knit to HTML. Knit to HTML After you do this, the menu will probably change to just Knit and you can just click on it to knit again. This will open a nice reader-friendly version of your notebook. You could send that file (called 01-import.html) to your editor and they could open it in a web browser. I use these knit files to publish my work on Github, but it is a bit more involved to do all that so we’ll skip that for now. 3.15 Review of what we’ve learned so far Most of this lesson has been about importing and combining data, with some data mutating thrown in for fun. (OK, I have an odd sense of what fun is.) Importing data into R (or any data science program) can sometimes be quite challenging, depending on the circumstances. Here we were working with well-formed data, but we still used quite a few tools from the tidyverse like readr (read_csv, write_rds) and dplyr (select, mutate). Here are the functions we used and what they do. Most are linked to documentation sites: install.packages() downloads an R package to your computer. Typically executed from within the Console and only once per computer. We installed the tidyverse, janitor and lubridate packages. library() loads a package. You need it for each package in each notebook, like library(tidyverse). read_csv() imports a csv file. You want that one, not read.csv. clean_names() is a function in the janitor package that standardizes column names. glimpse() is a view of your data where you can see all of the column names, their data type and a few examples of the data. head() prints the first 6 rows of your data unless you specify a different integer within the function. mutate() changes data. You can create new columns or overwrite existing ones. mdy() is a lubridate function to convert text into a date. There are other functions for different date orders. select() selects columns in your tibble. You can list all the columns to keep, or use - to remove columns. There are many variations. summary() gives you some quick summary statistics about your data like min, max, mean, median. write_rds() writes data out to a file in a format that preserves data types. 3.16 What’s next Importing data is just the first step of exploring a data set. We’ll work through the next chapter before we turn in any work on this. Please reach out to me if you have questions on what you’ve done so far. These are important skills you’ll use on future projects. "],["count-analysis.html", "Chapter 4 Summarize with count - analysis 4.1 Goals of this lesson 4.2 The questions we’ll answer 4.3 Setting up an analysis notebook 4.4 Introducing dplyr 4.5 Most appearances 4.6 Song/performer with most appearances 4.7 Song/Performer with most weeks at No. 1 4.8 Performer with most songs to reach No. 1 4.9 No. 1 hits in last five years 4.10 Top 10 hits overall (on your own) 4.11 A shortcut: count() 4.12 Complex filters 4.13 On your own 4.14 Review of what we’ve learned 4.15 Turn in your project 4.16 Soundtrack for this assignment", " Chapter 4 Summarize with count - analysis This chapter continues the Billboard Hot 100 project. In the previous chapter we downloaded, imported and cleaned the data. We’ll be working in the same project. This chapter is by Prof. McDonald and keyboard commands and screenshots are from the macOS perspective. 4.1 Goals of this lesson To use group by/summarize/arrange combination to count rows of data. To use filter to both focus data before summaries, and to logically end summarized lists. Introduce the shortcut count() function, along with complex filters. 4.2 The questions we’ll answer Now that we have the Billboard Hot 100 charts data in our project it’s time to find the answers to the following questions: Which performer had the most appearances on the Hot 100 chart at any position? Which song/performer combination has been on the charts the most number of weeks at any position? Which song/performer combination was No. 1 for the most number of weeks? Which performer had the most songs reach No. 1? Which performer had the most songs reach No. 1 in the most recent five years? Which performer had the most Top 10 hits overall? What are your guesses for the questions above? No peeking! Before we can get into the analysis, we need to set up a new notebook. 4.3 Setting up an analysis notebook At the end of the last notebook we exported our clean data as an .rds file. We’ll now create a new notebook and import that data. It will be much easier this time. If you don’t already have it open, go ahead and open your Billboard project. If your import notebook is still open, go ahead and close it. Use the + menu to start a new R Notebook. Update the title as “Billboard analysis” and then remove all the boilerplate text below the YAML metadata. Save the file as 02-analysis.Rmd in your project folder. Check your Environment tab (top right) and make sure the environment is empty. We don’t want to have any leftover data. If there is, then go under the Run menu and choose Restart R and Clear Output. Since we are starting a new notebook, we need to set up a few things. First up we want to list our goals. Add a headline and text describing the goals of this notebook. You are exploring the Billboard Hot 100 charts data. Go ahead and copy all the questions we outlined above into your notebook. Format those questions as a nice list. Start each line with a - or * followed by a space. There should be a blank line above and below the LIST but for the items IN the list, no blanks between lines. Now add a another headline (two hashes) called Setup. Add a chunk, also name it “setup” and add the tidyverse library. Run the chunk to load the library. I’m not showing this code because you got this. You’ve created a setup chunk in each notebook so far. 4.3.1 Import the data on your own In this next part I want you to think about how you’ve did the import in the last notebook and I want you to: Write a section to import the data using read_rds() and put it into an object called hot100. Yes, it is true that we haven’t talked about read_rds() yet but it works exactly the same way as read_csv(), so you should try to figure it out. Here are some hints and guides: Start a new section with a headline and text to say what you are doing Don’t forget to name your code chunk (this should all be getting familiar). read_rds() works the same was as read_csv(). The path should be data-processed/01-hot100.rds if you did the previous notebook properly. Remember the tibble needs to be named first and read data pushed into it. Add a glimpse to the chunk so you can refer to the data. Try real hard first before clicking here for the answer and result hot100 &lt;- read_rds(&quot;data-processed/01-hot100.rds&quot;) # peek at the data hot100 %&gt;% glimpse() ## Rows: 330,787 ## Columns: 7 ## $ chart_date &lt;date&gt; 1958-08-04, 1958-08-04, 1958-08-04, 1958-08-04, 1958-08… ## $ current_rank &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… ## $ song &lt;chr&gt; &quot;Poor Little Fool&quot;, &quot;Patricia&quot;, &quot;Splish Splash&quot;, &quot;Hard H… ## $ performer &lt;chr&gt; &quot;Ricky Nelson&quot;, &quot;Perez Prado And His Orchestra&quot;, &quot;Bobby … ## $ previous_rank &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ peak_rank &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1… ## $ wks_on_chart &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,… 4.4 Introducing dplyr One of the packages within the tidyverse is dplyr. Dplyr allows us to transform our data frames in ways that let us explore the data and prepare it for visualizing. It’s the R equivalent of common Excel functions like sort, filter and pivoting. There is a cheatsheet on the dplyr that you might find useful. Images courtesy Hadley. Yes, I personally asked him. OK, it was email, but still. We’ve used select(), mutate() and arrange() already, but we’ll introduce more dplyr functions in this chapter. 4.5 Most appearances Our first question: Which performer had the most appearances on the Hot 100 chart at any position? 4.5.1 Group &amp; Aggregate Before we dive into the code, let’s review this video about “Group and Aggregate” to get a handle on the concept. Let’s work through the logic of what we need to do before I explain exactly how to do it. Each row in the data is one song ranked on the chart. Each of those rows has the performer that recorded the song. To figure out how many times a performer is in the data, we need to count the number of rows with the same performer. We’ll use the tidyverse’s version of Group and Aggregate to get this answer. It is actually two different functions within dplyr that often work together: group_by() and summarize() 4.5.2 Summarize We’ll start with summarize() first because it can stand alone. The summarize() function computes tables about your data. Our logic above has us wanting a “summary” of how many times certain performer appears in data, hence we use this function. summarize() and summarise() are the same function, as R supports both the American and UK spelling of summarize. They work the same and I don’t care which you use. Here is an example if summarize() in a different context: Learn about your data with summarize() Much like the mutate() function we used earlier, within summarize() we list the name of the new column first, then assign to it the function and column we want to accomplish using =. The example above is giving us two summaries: It is applying a function mean() (or average) on all the values in the lifeExp column, and then again with min(), the lowest life expectancy in the data. In our case (we are working toward finding the performer with most appearances) we want to count the number of rows, and there is a function for that: n(). (Think “number of observations.”) Every row in the data is an appearance … we just need to count how many rows have each performer. But first, to show how this works, we’ll count all the rows in the data. Let’s write the code and run it on our code, then I’ll explain: Set up a new section with a headline, text and empty code chunk. Inside the code chunk, add the following: hot100 %&gt;% summarize( appearances = n() ) ## # A tibble: 1 × 1 ## appearances ## &lt;int&gt; ## 1 330787 We start with the tibble first and then pipe into summarize(). Within the function, we define our summary: We name the new column “appearances” because that is a descriptive column name for our result. We set that new column to count the number of rows. Basically we are summarizing the total number of rows in the data. AN ASIDE: Like with mutate, I often break up the arguments inside summarize() into new lines so they are easier to read. But I bet you’re asking: Professor, we want to count the number of times an performer has appeared, right? This is where we bring in a close friend to summarize() … the group_by() function. 4.5.3 Group by The group_by() function pre-sorts data into groups so that whatever function follows is applied within each of the groups. That means group_by() always has something following it, and that something is usually summarize(). If we group_by() performer before we summarize/count our rows, it will put all of the “Aerosmith” rows together, then all the “Bad Company” rows together, etc. and then it will count the rows within those groups … first those for Aerosmith and then those for Bad Company. Modify your code block to add the group_by: hot100 %&gt;% group_by(performer) %&gt;% summarize(appearances = n()) ## # A tibble: 10,235 × 2 ## performer appearances ## &lt;chr&gt; &lt;int&gt; ## 1 &quot;? (Question Mark) &amp; The Mysterians&quot; 33 ## 2 &quot;&#39;N Sync&quot; 172 ## 3 &quot;&#39;N Sync &amp; Gloria Estefan&quot; 20 ## 4 &quot;&#39;N Sync Featuring Nelly&quot; 20 ## 5 &quot;&#39;Til Tuesday&quot; 53 ## 6 &quot;\\&quot;Groove\\&quot; Holmes&quot; 14 ## 7 &quot;\\&quot;Little\\&quot; Jimmy Dickens&quot; 10 ## 8 &quot;\\&quot;Pookie\\&quot; Hudson&quot; 1 ## 9 &quot;\\&quot;Weird Al\\&quot; Yankovic&quot; 91 ## 10 &quot;(+44)&quot; 1 ## # … with 10,225 more rows What we get in return is a summarized table that shows all 10,000+ different performers that have been on the charts, and the number of rows in which they appear in the data. That’s great, but who had the most? 4.5.4 Arrange the results Remember in our import notebook when we sorted all the rows by the oldest chart date? We’ll use the same arrange() function here, but we’ll change the result to descending order, because journalists almost always want to know the most of something. Add the pipe and arrange function below and run it, then I’ll explain. hot100 %&gt;% group_by(performer) %&gt;% summarize(appearances = n()) %&gt;% arrange(desc(appearances)) ## # A tibble: 10,235 × 2 ## performer appearances ## &lt;chr&gt; &lt;int&gt; ## 1 Taylor Swift 1057 ## 2 Elton John 889 ## 3 Madonna 857 ## 4 Drake 787 ## 5 Kenny Chesney 776 ## 6 Tim McGraw 731 ## 7 Keith Urban 673 ## 8 Stevie Wonder 659 ## 9 Rod Stewart 657 ## 10 Mariah Carey 626 ## # … with 10,225 more rows We added the arrange() function and fed it the column of “appearances.” If we left it with just that, then it would list the smallest values first. Within the arrange function we wrapped our column in another function: desc() to change the order to “descending,” or the most on the top. I sometimes pipe the column name into the desc() function like this: arrange(appearances %&gt;% desc()). You can also put a - before the column name like this: arrange(-appearances)) but I think is out of favor among tidyverse worldview folk. 4.5.5 Get the top of the list We’ve printed 10,000 rows of data into our notebook when we really only wanted the Top 10 or so. You might think it doesn’t matter, but your knitted HTML file will store all that data and can make it a big file (as in hard drive space), so I try to avoid that when I can. We can use the head() command again to get our Top 10. It will give us a specified number of rows at the top of the table (with a default of six if we don’t specify.) There is a corresponding tail() function to get the last rows. Pipe the result into head() function set to 10 rows. hot100 %&gt;% group_by(performer) %&gt;% summarize(appearances = n()) %&gt;% arrange(appearances %&gt;% desc()) %&gt;% head(10) ## # A tibble: 10 × 2 ## performer appearances ## &lt;chr&gt; &lt;int&gt; ## 1 Taylor Swift 1057 ## 2 Elton John 889 ## 3 Madonna 857 ## 4 Drake 787 ## 5 Kenny Chesney 776 ## 6 Tim McGraw 731 ## 7 Keith Urban 673 ## 8 Stevie Wonder 659 ## 9 Rod Stewart 657 ## 10 Mariah Carey 626 If I was to explain the code above in English, I would describe it as this: We start with the hot100 data AND THEN we group by the data by performer AND THEN we summarize it by counting the number of rows in each group, calling the count “appearances” AND THEN we arrange the result by appearances in descending order AND THEN we keep just the first 10 rows Since we have our answer here and we’re not using the result later, we don’t need to create a new object or anything. Printing it to our notebook is sufficient. So, Taylor Swift … is that who you guessed? A little history here, Swift past Elton John in the summer of 2019. Elton John has been around a long time, but Swift’s popularity at a young age, plus changes in how Billboard counts plays in the modern era (like streaming) has rocketed her to the top. (Sorry, Rocket Man). AN IMPORTANT NOTE: The list we’ve created here is based on unique performer names, and as such considers collaborations separately. For instance, Drake is near the top of the list but those are only songs he performed alone and not the many, many collaborations he has had with other performers. So, songs by “Drake” are counted separately than “Drake featuring Future” and even “Future featuring Drake.” You’ll need to make this clear when you write your data drop in a later assignment. 4.6 Song/performer with most appearances Our quest here is this: Which song/performer combination has been on the charts the most number of weeks at any position? This is very similar to our quest to find the artist with the most appearances, but we have to consider both song and performer together because different artists can perform songs of the same name. For example, Adele’s song “Hold On” entered the Hot 100 at 49 in December 2021, but 18 different performers have had a song called “Hold On” on the Hot 100. Start a new section (headline, text describing goal and a new code chunk.) Add the code below to the chunk and run it and then I’ll outline it below. hot100 %&gt;% # start with the data, and then ... group_by(performer, song) %&gt;% # group by performer and song, and then .. summarize(appearances = n()) %&gt;% # count the rows with n(), and then ... arrange(desc(appearances)) # arrange by appearances in descending order ## `summarise()` has grouped output by &#39;performer&#39;. You can override using the `.groups` argument. ## # A tibble: 29,789 × 3 ## # Groups: performer [10,235] ## performer song appearances ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 The Weeknd Blinding Lights 90 ## 2 Imagine Dragons Radioactive 87 ## 3 AWOLNATION Sail 79 ## 4 Jason Mraz I&#39;m Yours 76 ## 5 LeAnn Rimes How Do I Live 69 ## 6 LMFAO Featuring Lauren Bennett &amp; GoonRock Party Rock Anthem 68 ## 7 OneRepublic Counting Stars 68 ## 8 Adele Rolling In The Deep 65 ## 9 Jewel Foolish Games/You Were… 65 ## 10 Carrie Underwood Before He Cheats 64 ## # … with 29,779 more rows The logic is actually straightforward: We want to count combinations over two columns: song, performer. When you group_by more then one column, it will group rows where the values are the same in all columns. i.e. all rows with both “Rush” as a performer and Tom Sawyer as a song. Rows with “Rush” and Red Barchetta will be considered in a different group. With summarize(), we name the new column first (we chose appearances), then describe what should fill it. In this case we filled the column using the n(), which counts the number of rows in each group. Once you have a summary table, we sort it by appearances and set it to descending order, which puts the highest value on the top. We will often use group_by(), summarize() and arrange() together, which is why I’ll refer to this as the GSA trio. They are like three close friends that always want to hang out together. So, what was your guess or this one? A little bit of history in that answer … The Weeknd’s Blinding Lights passed Imagine Dragon’s Radioactive some time in 2021. 4.6.1 Introducing filter() I showed you head() in the previous quest and that is useful to quickly cut off a list, but it does so indiscriminately. In this case, if we use the default head() that retains six rows, it would cut right in the middle of a tie at 68 records. (at least with data through 2021). A better strategy is to cut off the list at a logical place using filter(). Let’s dive into this new function: Filtering is one of those Basic Data Journalism Functions: The dplyr function filter() reduces the number of rows in our data based on one or more criteria within the data. The syntax works like this: # this is psuedo code. don&#39;t run it data %&gt;% filter(variable comparison value) # example hot100 %&gt;% filter(performer == &quot;Judas Priest&quot;) The filter() function typically works in this order: What is the variable (or column) you are searching in. What is the comparison you want to do. Equal to? Greater than? What is the observation (or value in the data) you are looking for? Note the two equals signs == in our Judas Priest example above. It’s important to use two of them when you are asking if a value is “true” or “equal to,” as a single = typically means you are assigning a value to something. 4.6.1.1 Comparisons: Logical tests There are a number of these logical test for the comparison: Operator Definition x &lt; y Less than x &gt; y Greater than x == y Equal to x &lt;= y Less than or equal to x &gt;= y Greater than or equal to x !- y Not equal to x %in% c(y,z) In a group is.na(x) Is NA !is.na(x) Is not NA Where you apply a filter matters. If we filter before group by/summarize/arrange (GSA) we are focusing the data before we summarize. If we filter after the GSA, we are affecting only the results of the summarize function, which is what we want to do here. 4.6.1.2 Filter to a logical cutoff In this case, I want you to use filter after the GSA actions to include only results with 65 or more appearances. Edit your current chunk to add a filter as noted in the example below. I’ll explain it after. hot100 %&gt;% group_by(performer, song) %&gt;% summarize(appearances = n()) %&gt;% arrange(appearances %&gt;% desc()) %&gt;% filter(appearances &gt;= 65) # this is the new line ## `summarise()` has grouped output by &#39;performer&#39;. You can override using the `.groups` argument. ## # A tibble: 9 × 3 ## # Groups: performer [9] ## performer song appearances ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 The Weeknd Blinding Lights 90 ## 2 Imagine Dragons Radioactive 87 ## 3 AWOLNATION Sail 79 ## 4 Jason Mraz I&#39;m Yours 76 ## 5 LeAnn Rimes How Do I Live 69 ## 6 LMFAO Featuring Lauren Bennett &amp; GoonRock Party Rock Anthem 68 ## 7 OneRepublic Counting Stars 68 ## 8 Adele Rolling In The Deep 65 ## 9 Jewel Foolish Games/You Were … 65 Let’s break down that last line: filter() is the function. The first argument in the function is the column we are looking in, appearances in our case. We then provide a comparison operator &gt;= to get “greater than or equal to.” We then give the value to compare, 65 in our case. 4.7 Song/Performer with most weeks at No. 1 We introduced filter() in the last quest to limit the summary. For this quest you’ll need to filter the data before the group by/summarize/arrange trio. Let’s review the quest: Which performer/song combination was No. 1 for the most number of weeks? While this quest is very similar to the one above, it really helps to think about the logic of what you need and then build the query one line at a time to make each line works. Let’s talk through the logic: We are starting with our hot100 data. Do we want to consider all the data? In this case, no: We only want songs that have a current_rank of 1. This means we will filter before any summarizing. Then we want to count the number of rows with the same performer and song combinations. This means we need to group_by both performer and song. Since we are counting rows, we need use n() as our summarize function, which counts the number or rows in each group. So let’s step through this with code: Create a section with a headline, text and code chunk Start with the hot100 data and then pipe into filter(). Within the filter, set the current_rank to be == to 1. Run the result and check it hot100 %&gt;% filter(current_rank == 1) ## # A tibble: 3,308 × 7 ## chart_date current_rank song performer previous_rank peak_rank wks_on_chart ## &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1958-08-04 1 Poor … Ricky Ne… NA 1 1 ## 2 1958-08-11 1 Poor … Ricky Ne… 1 1 2 ## 3 1958-08-18 1 Nel B… Domenico… 2 1 3 ## 4 1958-08-25 1 Littl… The Eleg… 2 1 4 ## 5 1958-09-01 1 Nel B… Domenico… 2 1 5 ## 6 1958-09-08 1 Nel B… Domenico… 1 1 6 ## 7 1958-09-15 1 Nel B… Domenico… 1 1 7 ## 8 1958-09-22 1 Nel B… Domenico… 1 1 8 ## 9 1958-09-29 1 It&#39;s … Tommy Ed… 3 1 7 ## 10 1958-10-06 1 It&#39;s … Tommy Ed… 1 1 8 ## # … with 3,298 more rows The result should show only songs with a 1 for current_rank. The rest of our logic is just like our last quest. We need to group by the song and performer and then summarize using n() to count the rows. Edit your existing chunk to add the group_by and summarize functions. Name your new column appearances and set it to count the rows with n(). While I will implore you to write and run your code one line at a time, group_by() won’t actually show you any different results, so I usually write group_by() and summarize() together. Try this on your own before you peek hot100 %&gt;% filter(current_rank == 1) %&gt;% group_by(performer, song) %&gt;% summarize(appearances = n()) ## `summarise()` has grouped output by &#39;performer&#39;. You can override using the `.groups` argument. ## # A tibble: 1,132 × 3 ## # Groups: performer [749] ## performer song appearances ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 ? (Question Mark) &amp; The Mysterians 96 Tears 1 ## 2 &#39;N Sync It&#39;s Gonna Be Me 2 ## 3 24kGoldn Featuring iann dior Mood 8 ## 4 2Pac Featuring K-Ci And JoJo How Do U Want It/California L… 2 ## 5 50 Cent In Da Club 9 ## 6 50 Cent Featuring Nate Dogg 21 Questions 4 ## 7 50 Cent Featuring Olivia Candy Shop 9 ## 8 6ix9ine &amp; Nicki Minaj Trollz 1 ## 9 A Taste Of Honey Boogie Oogie Oogie 3 ## 10 a-ha Take On Me 1 ## # … with 1,122 more rows Look at your results to make sure you have the three columns you expect: performer, song and appearances. This doesn’t quite get us where we want because it lists the results alphabetically by the performer. You need to arrange the data to show us the most appearances at the top. Edit your chunk to add the arrange() function to sort by appearances in desc() order. This is just like our last quest. Maybe check your last chunk on how you did this hot100 %&gt;% filter(current_rank == 1) %&gt;% group_by(performer, song) %&gt;% summarize(appearances = n()) %&gt;% arrange(appearances %&gt;% desc()) ## `summarise()` has grouped output by &#39;performer&#39;. You can override using the `.groups` argument. ## # A tibble: 1,132 × 3 ## # Groups: performer [749] ## performer song appearances ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Lil Nas X Featuring Billy Ray Cyrus Old Town Road 19 ## 2 Luis Fonsi &amp; Daddy Yankee Featuring Justin Bieber Despacito 16 ## 3 Mariah Carey &amp; Boyz II Men One Sweet Day 16 ## 4 Boyz II Men I&#39;ll Make Love… 14 ## 5 Elton John Candle In The … 14 ## 6 Los Del Rio Macarena (Bays… 14 ## 7 Mariah Carey We Belong Toge… 14 ## 8 Mark Ronson Featuring Bruno Mars Uptown Funk! 14 ## 9 The Black Eyed Peas I Gotta Feeling 14 ## 10 Whitney Houston I Will Always … 14 ## # … with 1,122 more rows You have your answer now (you go, Lil Nas) but we are listing more than 1,000 rows. Let’s cut this off at a logical place like we did in our last quest. Use filter() to cut your summary off at appearances of 14 or greater. You’ve done this before … try it on your own! hot100 %&gt;% filter(current_rank == 1) %&gt;% group_by(performer, song) %&gt;% summarize(appearances = n()) %&gt;% arrange(appearances %&gt;% desc()) %&gt;% filter(appearances &gt;= 14) ## `summarise()` has grouped output by &#39;performer&#39;. You can override using the `.groups` argument. ## # A tibble: 10 × 3 ## # Groups: performer [10] ## performer song appearances ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Lil Nas X Featuring Billy Ray Cyrus Old Town Road 19 ## 2 Luis Fonsi &amp; Daddy Yankee Featuring Justin Bieber Despacito 16 ## 3 Mariah Carey &amp; Boyz II Men One Sweet Day 16 ## 4 Boyz II Men I&#39;ll Make Love… 14 ## 5 Elton John Candle In The … 14 ## 6 Los Del Rio Macarena (Bays… 14 ## 7 Mariah Carey We Belong Toge… 14 ## 8 Mark Ronson Featuring Bruno Mars Uptown Funk! 14 ## 9 The Black Eyed Peas I Gotta Feeling 14 ## 10 Whitney Houston I Will Always … 14 Now you have the answers to the performer/song with the most weeks at No. 1 with a logical cutoff. If you add to the data, that logic will still hold and not cut off arbitrarily at a certain number of records. 4.8 Performer with most songs to reach No. 1 Our new quest is this: Which performer had the most songs reach No. 1? The answer might be easier to guess if you know music history, but perhaps not. This sounds similar to our last quest, but there is a distinct difference. (That’s a bad joke that will reveal itself here in a bit.) Again, let’s think through the logic of what we have to do to get our answer: We need to consider only No. 1 songs. (filter!) Because a song could be No. 1 for more than one week, we need to consider the same song/performer combination only once. Another way to say this is we need unique or distinct combinations of song/performer. (We’ll introduce a new function to find this.) Once we have all the unique No. 1 songs in a list, then we can group by performer and count how many times many times they are on the list. Let’s start by getting the No. 1 songs. You’ve did this in the last quest. Create a new section with a headline, text and code chunk. Start with the hot100 data and filter it so you only have current_rank of 1. Try on your own. You got this! hot100 %&gt;% filter(current_rank == 1) ## # A tibble: 3,308 × 7 ## chart_date current_rank song performer previous_rank peak_rank wks_on_chart ## &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1958-08-04 1 Poor … Ricky Ne… NA 1 1 ## 2 1958-08-11 1 Poor … Ricky Ne… 1 1 2 ## 3 1958-08-18 1 Nel B… Domenico… 2 1 3 ## 4 1958-08-25 1 Littl… The Eleg… 2 1 4 ## 5 1958-09-01 1 Nel B… Domenico… 2 1 5 ## 6 1958-09-08 1 Nel B… Domenico… 1 1 6 ## 7 1958-09-15 1 Nel B… Domenico… 1 1 7 ## 8 1958-09-22 1 Nel B… Domenico… 1 1 8 ## 9 1958-09-29 1 It&#39;s … Tommy Ed… 3 1 7 ## 10 1958-10-06 1 It&#39;s … Tommy Ed… 1 1 8 ## # … with 3,298 more rows Now look at the result. Note how “Poor Little Fool” shows up more than once? Other songs do as well. If we counted rows by performer now, that would tell us the number of weeks they’ve had No. 1 songs, not how many different songs have made No. 1. 4.8.1 Using distinct() Our next challenge in our logic is to show only unique performer/song combinations. We do this with distinct(). We feed the distinct() function with the variables we want to consider together, in our case the perfomer and song. All other columns are dropped since including them would mess up their distinctness. Add the distinct() function to your code chunk. hot100 %&gt;% filter(current_rank == 1) %&gt;% distinct(song, performer) ## # A tibble: 1,132 × 2 ## song performer ## &lt;chr&gt; &lt;chr&gt; ## 1 Poor Little Fool Ricky Nelson ## 2 Nel Blu Dipinto Di Blu (Volaré) Domenico Modugno ## 3 Little Star The Elegants ## 4 It&#39;s All In The Game Tommy Edwards ## 5 It&#39;s Only Make Believe Conway Twitty ## 6 Tom Dooley The Kingston Trio ## 7 To Know Him, Is To Love Him The Teddy Bears ## 8 The Chipmunk Song The Chipmunks With David Seville ## 9 Smoke Gets In Your Eyes The Platters ## 10 Stagger Lee Lloyd Price ## # … with 1,122 more rows Now we have a list of just No. 1 songs! 4.8.2 Summarize the performers Now that we have our list of No. 1 songs, we can “count” the number of times a performer is in the list to know how many No. 1 songs they have. We’ll again use the group_by/summarize/arrange combination for this, but we are only grouping by performer since that is what we are counting. Edit your chunk to add a group_by on performer and then a summarize() to count the rows. Name the new column no_hits. Run it. After you are sure the group_by/summarize runs, add an arrange() to show the no1_hits in descending order. You’ve done this. Give it ago! hot100 %&gt;% filter(current_rank == 1) %&gt;% distinct(song, performer) %&gt;% group_by(performer) %&gt;% summarize(no1_hits = n()) %&gt;% arrange(no1_hits %&gt;% desc()) ## # A tibble: 749 × 2 ## performer no1_hits ## &lt;chr&gt; &lt;int&gt; ## 1 The Beatles 19 ## 2 Mariah Carey 16 ## 3 Madonna 12 ## 4 Michael Jackson 11 ## 5 Whitney Houston 11 ## 6 The Supremes 10 ## 7 Bee Gees 9 ## 8 The Rolling Stones 8 ## 9 Janet Jackson 7 ## 10 Stevie Wonder 7 ## # … with 739 more rows 4.8.3 Filter for a good cutoff Like we did earlier, use a filter() after your arrange to cut the list off at a logical place. Edit your chunk to filter the summary to show performer with 8 or more No. 1 hits. You can do this. Really hot100 %&gt;% filter(current_rank == 1) %&gt;% distinct(song, performer) %&gt;% group_by(performer) %&gt;% summarize(no1_hits = n()) %&gt;% arrange(no1_hits %&gt;% desc()) %&gt;% filter(no1_hits &gt;= 8) ## # A tibble: 8 × 2 ## performer no1_hits ## &lt;chr&gt; &lt;int&gt; ## 1 The Beatles 19 ## 2 Mariah Carey 16 ## 3 Madonna 12 ## 4 Michael Jackson 11 ## 5 Whitney Houston 11 ## 6 The Supremes 10 ## 7 Bee Gees 9 ## 8 The Rolling Stones 8 So, The Beatles. Was that your guess? Look closely at that list … who has any chance of topping them? 4.9 No. 1 hits in last five years Which performer had the most songs reach No. 1 in the most recent five years? Let’s talk through the logic. This is very similar to the No. 1 hits above but with two differences: In addition to filtering for No. 1 songs, we also want to filter for songs in 2017-2021. We might need to adjust our last filter for a better “break point.” We haven’t talked about filtering dates, so let me tell you this: You can use filter operations on dates just like you do any other text. This will give you rows after the last day of 2016. filter(chart_date &gt; &quot;2016-12-31&quot;) But since we need this filter before our group, we can do this within the same filter function where we get the number one songs. Create a new section (headline, text, chunk). Build (from scratch) the same filter, group_by, summarize and arrange as above, but leave out the cut-off filter at the end. (We’ll need to adjust that based on these results). Make sure it runs. EDIT your filter to put a comma after current_rank == 1 and then add this filter: chart_date &gt; \"2016-12-31\". Run the code. Build a new cut-off filter at the end keep only rows with more than 1 top_hits. No, really. Try it on your own first. hot100 %&gt;% filter( current_rank == 1, chart_date &gt; &quot;2016-12-31&quot; ) %&gt;% distinct(song, performer) %&gt;% group_by(performer) %&gt;% summarize(top_hits = n()) %&gt;% arrange(top_hits %&gt;% desc()) %&gt;% filter(top_hits &gt; 1) ## # A tibble: 9 × 2 ## performer top_hits ## &lt;chr&gt; &lt;int&gt; ## 1 Drake 5 ## 2 BTS 4 ## 3 Taylor Swift 4 ## 4 Ariana Grande 3 ## 5 Cardi B 2 ## 6 Ed Sheeran 2 ## 7 Olivia Rodrigo 2 ## 8 The Weeknd 2 ## 9 Travis Scott 2 4.10 Top 10 hits overall (on your own) Which performer had the most Top 10 hits overall? This one I want you to do on your own. The logic is very similar to the “Most No. 1 hits” quest you did before, but you need to adjust your filter to find songs within position 1 through 10. Don’t over think it, but do recognize that the “top” of the charts are smaller numbers, not larger ones. Make a new section Describe what you are doing Do it using the group_by/summarize method Filter to cut off at a logical number or rows. (i.e., don’t stop at a tie) 4.11 A shortcut: count() In the interest of full disclosure but at the risk of confusing you, I must reveal this fact: We count stuff in data science (and journalism) all the time. So dplyr has a shortcut to group, count and arrange rows of data. We needed to use the long way above because a) we will use group_by() and summarize() with other math that isn’t just counting rows, and b) you need to understand what is happening inside count(), which is really just using group_by/summarize/arrange under the hood. The count() function takes the columns you want to group and then does the summarize on n() for you: hot100 %&gt;% count(performer) ## # A tibble: 10,235 × 2 ## performer n ## &lt;chr&gt; &lt;int&gt; ## 1 &quot;? (Question Mark) &amp; The Mysterians&quot; 33 ## 2 &quot;&#39;N Sync&quot; 172 ## 3 &quot;&#39;N Sync &amp; Gloria Estefan&quot; 20 ## 4 &quot;&#39;N Sync Featuring Nelly&quot; 20 ## 5 &quot;&#39;Til Tuesday&quot; 53 ## 6 &quot;\\&quot;Groove\\&quot; Holmes&quot; 14 ## 7 &quot;\\&quot;Little\\&quot; Jimmy Dickens&quot; 10 ## 8 &quot;\\&quot;Pookie\\&quot; Hudson&quot; 1 ## 9 &quot;\\&quot;Weird Al\\&quot; Yankovic&quot; 91 ## 10 &quot;(+44)&quot; 1 ## # … with 10,225 more rows To get the same pretty table you still have to rename the new column and reverse the sort, you just do it differently as arguments within the count() function. You can view the count() options here. Add this chunk to your notebook (with a note you are trying count()) so you have it to refer to. hot100 %&gt;% count(performer, name = &quot;appearances&quot;, sort = TRUE) %&gt;% filter(appearances &gt; 600) ## # A tibble: 13 × 2 ## performer appearances ## &lt;chr&gt; &lt;int&gt; ## 1 Taylor Swift 1057 ## 2 Elton John 889 ## 3 Madonna 857 ## 4 Drake 787 ## 5 Kenny Chesney 776 ## 6 Tim McGraw 731 ## 7 Keith Urban 673 ## 8 Stevie Wonder 659 ## 9 Rod Stewart 657 ## 10 Mariah Carey 626 ## 11 Michael Jackson 612 ## 12 Chicago 607 ## 13 Rascal Flatts 604 So the code above does same things here as we did in our first quest, but quicker. IMPORTANT: We concentrate on using group_by/summarize/arrange because it can do SO MUCH MORE than count(). Count can ONLY count rows. It can’t do any other kind of math in summarize. 4.12 Complex filters You can combine filters in different ways to really target which rows to keep. For these I want you to play around a bit. Copy each of the examples below into your notebook, but change the song and/or artists to some that you like. 4.12.1 Multiple truths If you want filter data for when two or more things are true, you can write two equations and combine with &amp;. Only rows where both sides prove true are returned. # When Poor Little Fool was No. 1, but not any other position hot100 %&gt;% filter(song == &quot;Poor Little Fool&quot; &amp; current_rank == 1) %&gt;% select(chart_date:performer) ## # A tibble: 2 × 4 ## chart_date current_rank song performer ## &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1958-08-04 1 Poor Little Fool Ricky Nelson ## 2 1958-08-11 1 Poor Little Fool Ricky Nelson 4.12.2 Either is true If you want an or filter, then you write two equations with a | between them. # songs by Adam Sandler OR Alabama Shakes hot100 %&gt;% filter(performer == &quot;Adam Sandler&quot; | performer == &quot;Alabama Shakes&quot;) %&gt;% select(chart_date:performer) ## # A tibble: 4 × 4 ## chart_date current_rank song performer ## &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1999-01-02 80 The Chanukah Song Adam Sandler ## 2 1999-01-09 98 The Chanukah Song Adam Sandler ## 3 2013-03-02 100 Hold On Alabama Shakes ## 4 2013-03-09 93 Hold On Alabama Shakes | is the Shift of the \\ key above Return on your keyboard. That | character is also sometimes called a “pipe,” which gets confusing in R with %&gt;%.) 4.12.3 Mixing criteria If you have multiple criteria, you separate them with a comma ,. Note I’ve also added returns to make the code more readable and added distinct to songs only once. # gives us rows with either Taylor Swift or Drake, # but only those that reached No. 1 hot100 %&gt;% filter( performer == &quot;Taylor Swift&quot; | performer == &quot;Drake&quot;, current_rank == 1 ) %&gt;% distinct(current_rank, song, performer) ## # A tibble: 12 × 3 ## current_rank song performer ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 We Are Never Ever Getting Back Together Taylor Swift ## 2 1 Shake It Off Taylor Swift ## 3 1 Blank Space Taylor Swift ## 4 1 Look What You Made Me Do Taylor Swift ## 5 1 God&#39;s Plan Drake ## 6 1 Nice For What Drake ## 7 1 In My Feelings Drake ## 8 1 Toosie Slide Drake ## 9 1 Cardigan Taylor Swift ## 10 1 Willow Taylor Swift ## 11 1 What&#39;s Next Drake ## 12 1 All Too Well (Taylor&#39;s Version) Taylor Swift 4.12.4 Search within a string And if you want to search for text within the data, you can use str_detect() to look for specific characters within a value to filter rows. str_detect() needs two arguments: 1) What column to search in, and 2) what to search for “in quotes.” I also use distinct() here to show only unique song/performer combinations. # Songs where &quot;2 Chainz&quot; was among performers hot100 %&gt;% filter(str_detect(performer, &quot;2 Chainz&quot;)) %&gt;% distinct(song, performer) ## # A tibble: 40 × 2 ## song performer ## &lt;chr&gt; &lt;chr&gt; ## 1 Mercy Kanye West, Big Sean, Pusha T, 2 Chainz ## 2 Beez In The Trap Nicki Minaj Featuring 2 Chainz ## 3 No Lie 2 Chainz Featuring Drake ## 4 Birthday Song 2 Chainz Featuring Kanye West ## 5 Yuck! 2 Chainz Featuring Lil Wayne ## 6 Bandz A Make Her Dance Juicy J Featuring Lil Wayne &amp; 2 Chainz ## 7 My Moment DJ Drama Featuring 2 Chainz, Meek Mill &amp; Jeremih ## 8 F**kin Problems A$AP Rocky Featuring Drake, 2 Chainz &amp; Kendrick Lamar ## 9 I&#39;m Different 2 Chainz ## 10 R.I.P. Young Jeezy Featuring 2 Chainz ## # … with 30 more rows Of course there is much, much more. 4.13 On your own Now I want you to find something else on your own. It doesn’t matter what it is. Just find something about a performer or song you like. Start a new section with a Markdown headline Use Markdown text to declare what you are looking for Find it! After your code, explain what functions you used and why (like what did they do for you) 4.14 Review of what we’ve learned We introduced a number of new functions in this lesson, most of them from the dplyr package. Mostly we filtered and summarized our data. Here are the functions we introduced in this chapter, many with links to documentation: filter() returns only rows that meet logical criteria you specify. summarize() builds a summary table about your data. You can count rows n() or do math on numerical values, like mean(). group_by() is often used with summarize() to put data into groups before building a summary table based on the groups. distinct() returns rows based on unique values in columns you specify. i.e., it deduplicates data. count() is a shorthand for the group_by/summarize operation to count rows based on groups. You can name your summary columns and sort the data within the same function. 4.15 Turn in your project Make sure everything runs properly (Restart R and Run All Chunks) and then Knit to HTML. Zip the folder. Upload to the Canvas assignment. 4.16 Soundtrack for this assignment This lesson was constructed with the vibes of The Bright Light Social Hour. They’ve never had a song on the Hot 100 (at least not through 2021). hot100 %&gt;% filter(str_detect(performer, &quot;Bright Light&quot;)) ## # A tibble: 0 × 7 ## # … with 7 variables: chart_date &lt;date&gt;, current_rank &lt;dbl&gt;, song &lt;chr&gt;, ## # performer &lt;chr&gt;, previous_rank &lt;dbl&gt;, peak_rank &lt;dbl&gt;, wks_on_chart &lt;dbl&gt; "],["sums-import.html", "Chapter 5 Summarize with math - import 5.1 About the story: Military surplus transfers 5.2 The questions we will answer 5.3 Create your project 5.4 Import/cleaning notebook 5.5 Things we learned in this lesson", " Chapter 5 Summarize with math - import This chapter is by Prof. McDonald, who uses macOS. Note: The data you end up using might be updated since the writing of this chapter, especially screenshot examples. With our Billboard assignment, we went through some common data wrangling processes — importing data, cleaning it and querying it for answers. All of our answers involved counting numbers of rows using group_by, summmarize and arrange (which I dub GSA). For this data story we need the summary trio GSA again but we must do different kinds of math within our summarize functions, mainly sum(). 5.1 About the story: Military surplus transfers In June 2020, Buzzfeed published the story Police Departments Have Received Hundreds Of Millions Of Dollars In Military Equipment Since Ferguson about the amount of military equipment transferred to local law enforcement agencies since Michael Brown was killed in Ferguson, Missouri. After Brown’s death there was a public outcry after “what appeared to be a massively disproportionate show of force during protests brought scrutiny to a federal program that transfers unused military equipment to local law enforcement.” Reporter John Templon used data from the Law Enforcement Support Office for the update on the program and published his data analysis, which he did in Python. You will analyze the same dataset focusing on some local police agencies and write a short data drop about transfers to those agencies. 5.1.1 The LESO program The Defense Logistics Agency transfers surplus military equipment to local law enforcement through its Law Enforcement Support Office. You can find more information about the program here. The agency updates the data quarterly and the data I’ve collected contains transfers through December 31, 2021 as of this writing. The original file is linked from the headline “ALASKA - WYOMING AND US TERRITORIES.” Note: Screenshots and Screencast walkthroughs might use older data. The data there comes in an Excel spreadsheet that has a new sheet for each state. I used R to pull the data from each sheet and combine it into a single data set and I’ll cover the process I used in class, but you won’t have to do that part. I will supply a link to the combined data below. 5.1.2 About the data There is no data dictionary or record layout included with the data but I have corresponded with the Defense Logistics Agency to get a decent understanding of what is included. Columns in bold are those we care about the most. sheet: Which sheet the data came from. This is an artifact from the data merging script. state: A two-letter designation for the state of the agency. agency_name: This is the agency that got the equipment. nsn: A special number that identifies the item. It is not germane to this specific assignment. item_name: The item transferred. Googling the names can sometimes yield more info on specific items. quantity: The number of the “units” the agency received. ui: Unit of measurement (item, kit, etc.) acquisition_value: a cost per unit for the item. demil_code: Another special code not germane to this assignment. demil_ic: Another special code not germane to this assignment. ship_date: The date the item(s) were sent to the agency. station_type: What kind of law enforcement agency made the request. Here is a glimpse of our main columns of interest, except for the date: ## Rows: 10 ## Columns: 5 ## $ state &lt;chr&gt; &quot;KY&quot;, &quot;SC&quot;, &quot;CA&quot;, &quot;TX&quot;, &quot;OH&quot;, &quot;NC&quot;, &quot;CA&quot;, &quot;MI&quot;, &quot;AZ&quot;… ## $ agency_name &lt;chr&gt; &quot;MEADE COUNTY SHERIFF DEPT&quot;, &quot;PROSPERITY POLICE DEPT… ## $ item_name &lt;chr&gt; &quot;GENERATOR SET,DIESEL ENGINE&quot;, &quot;RIFLE,7.62 MILLIMETE… ## $ quantity &lt;dbl&gt; 5, 1, 32, 1, 1, 1, 1, 1, 1, 1 ## $ acquisition_value &lt;dbl&gt; 4623.09, 138.00, 16.91, 749.00, 749.00, 138.00, 499.… Each row of data is a transfer of a particular type of item from the U.S. Department of Defense to a local law enforcement agency. The row includes the name of the item, the quantity, and the value ($) of a single unit. What the data doesn’t have is the total value of the items in the shipment. If there are 5 generators as noted in the first row above and the cost of each one is $4623.09, we have to multiply the quantity times the acquisition_value to get the total value of that equipment. We will do that as part of the assignment. The local agencies really only pay the shipping costs for the item, so you can’t say they paid for the items, so the total value you calculate is the “value” of the items, not their cost to the local agency. One last thing on this: If you read the LESO Public Information page and the FAQ closely you’ll see the most recent year of data includes “non-controlled” items like boots, blankets and cameras. These non-controlled items are removed from the data a year after the transfer, so the most recent year will have WAY MORE items listed. 5.2 The questions we will answer All answers will be based on data from Jan. 1, 2010 to present. In addition, we’ll only consider Texas agencies as you answer the following. For each agency in Texas, find the summed quantity and summed total value of the equipment they received. (When I say “summed” that means we’ll add together all the values in the column.) Once you have the list, we’ll think about what stands out and why? We’ll take the list above, but filter that summary to show only the following local agencies: AUSTIN POLICE DEPT SAN MARCOS POLICE DEPT TRAVIS COUNTY SHERIFFS OFFICE UNIV OF TEXAS SYSTEM POLICE HI_ED WILLIAMSON COUNTY SHERIFF’S OFFICE For each of the agencies above we’ll use summarize to get the summed quantity and summed total_value of each item shipped to the agency. We’ll create a summarized list for each agency so we can write about each one. You’ll research some of the more interesting items the agencies received (i.e. Google the names) so you can include them in your data drop. 5.3 Create your project We will build the same project structure that we did with the Billboard project. In fact, all our class projects will have this structure. Since we’ve done this before, some of the directions are less detailed. With RStudio open, make sure you don’t have a project open. Go to File &gt; Close project. Use the create project button (or File &gt; New project) to create a new project in a “New Directory.” Name the directory “yourname-military-surplus.” Create two folders: data-raw and data-processed. 5.4 Import/cleaning notebook Again, like Billboard, we’ll create a notebook specifically for downloading, cleaning and prepping our data. Create your RNotebook. Rename the title “Military Surplus import/clean.” Remove the rest of the boilerplate template. Save the file and name it 01-import.Rmd. 5.4.1 Add the goals of the notebook In Markdown, add a headline noting these are notebook goals. Add the goals below: - Download the data - Import the data - Clean datatypes - Remove unnecessary columns - Create a total_value column - Filter to Texas agencies - Filter the date range (since Jan. 1 2010) - Export the cleaned data NOTE: Most of these are pretty standard in a import/cleaning notebook. Filtering to Texas agencies is specific to this data set, but we would do all these other things in all projects. 5.4.2 Add a setup section This is the section where we add our libraries and such. Again, every notebook has this section, though the packages may vary on need. Add a headline and text about what we are doing: Our project setup. Add a code chunk to load the libraries. You should only need tidyverse for this notebook because the data already has clean names (no need for janitor) and the dates will import correctly (no need for lubridate). library(tidyverse) 5.4.3 Download the data A new section means a new headline and description. Add it. It is good practice to describe and link to the data you will be using. You can use this: The Defense Logistics Agency transfers surplus military equipment to local law enforcement through its [Law Enforcement Support Office](https://www.dla.mil/DispositionServices/Offers/Reutilization/LawEnforcement/PublicInformation/). You can find more information [about the program here](https://www.dla.mil/DispositionServices/Offers/Reutilization/LawEnforcement/ProgramFAQs/). Use the download.file() function to download the date into your data-raw folder. Remember you need two arguments: download.file(&quot;url_to_data&quot;, &quot;path_to_folder/filename.csv&quot;) The data can be found at this url: https://github.com/utdata/rwd-r-leso/blob/main/data-processed/leso.csv?raw=true It should be saved into your data-raw folder with a name for the file. Once you’ve built your code chunk and run it, you should make sure the file downloaded into the correct place: in your data-raw folder. You should be able to do this on your own. Really. # You can comment the line below once you have the data download.file(&quot;https://github.com/utdata/rwd-r-leso/blob/main/data-processed/leso.csv?raw=true&quot;, &quot;data-raw/leso.csv&quot;) 5.4.4 Import the data We are again working with a CSV, or comma-separated-values text file. Add a new section: Headline, text if needed, code chunk. I suggest you build the code chunk a bit at a time in this order: Use read_csv() to read the file from our data-raw folder. Edit that line to put the result into a tibble object using &lt;-. Name your new tibble leso. Print the tibble as a table to the screen again by putting the tibble object on a new line and running it. This allows you to see it in columnar form. Try real hard first before clicking here for the answer. Note the book will also show the response. # assigning the tibble leso &lt;- read_csv(&quot;data-raw/leso.csv&quot;) ## Rows: 124848 Columns: 12 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (7): state, agency_name, nsn, item_name, ui, demil_code, station_type ## dbl (4): sheet, quantity, acquisition_value, demil_ic ## dttm (1): ship_date ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # printing the tibble leso ## # A tibble: 124,848 × 12 ## sheet state agency_name nsn item_name quantity ui acquisition_val… ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 AL ABBEVILLE PO… 2540-… BALLISTIC B… 10 Kit 15872. ## 2 1 AL ABBEVILLE PO… 1240-… OPTICAL SIG… 1 Each 246. ## 3 1 AL ABBEVILLE PO… 1005-… MOUNT,RIFLE 10 Each 1626 ## 4 1 AL ABBEVILLE PO… 1240-… SIGHT,REFLEX 9 Each 333 ## 5 1 AL ABBEVILLE PO… 5855-… ILLUMINATOR… 10 Each 926 ## 6 1 AL ABBEVILLE PO… 2355-… MINE RESIST… 1 Each 658000 ## 7 1 AL ABBEVILLE PO… 2320-… TRUCK,UTILI… 1 Each 62627 ## 8 1 AL ABBEVILLE PO… 1385-… UNMANNED VE… 1 Each 10000 ## 9 1 AL ABBEVILLE PO… 6760-… CAMERA ROBOT 1 Each 1500 ## 10 1 AL ABBEVILLE PO… 2320-… TRUCK,UTILI… 1 Each 62627 ## # … with 124,838 more rows, and 4 more variables: demil_code &lt;chr&gt;, ## # demil_ic &lt;dbl&gt;, ship_date &lt;dttm&gt;, station_type &lt;chr&gt; 5.4.5 Glimpse the data In a new block, print the tibble but pipe it into glimpse() so you can see all the column names. leso %&gt;% glimpse() ## Rows: 124,848 ## Columns: 12 ## $ sheet &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;… ## $ agency_name &lt;chr&gt; &quot;ABBEVILLE POLICE DEPT&quot;, &quot;ABBEVILLE POLICE DEPT&quot;, &quot;A… ## $ nsn &lt;chr&gt; &quot;2540-01-565-4700&quot;, &quot;1240-DS-OPT-SIGH&quot;, &quot;1005-01-587… ## $ item_name &lt;chr&gt; &quot;BALLISTIC BLANKET KIT&quot;, &quot;OPTICAL SIGHTING AND RANGI… ## $ quantity &lt;dbl&gt; 10, 1, 10, 9, 10, 1, 1, 1, 1, 1, 1, 1, 3, 12, 1, 5, … ## $ ui &lt;chr&gt; &quot;Kit&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each… ## $ acquisition_value &lt;dbl&gt; 15871.59, 245.88, 1626.00, 333.00, 926.00, 658000.00… ## $ demil_code &lt;chr&gt; &quot;D&quot;, &quot;D&quot;, &quot;D&quot;, &quot;D&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;Q&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C… ## $ demil_ic &lt;dbl&gt; 1, NA, 1, 1, 1, 1, 1, 3, 7, 1, 1, NA, 1, 1, 1, 1, 1,… ## $ ship_date &lt;dttm&gt; 2018-01-30, 2016-06-02, 2016-09-19, 2016-09-14, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… 5.4.5.1 Checking datatypes Take a look at your glimpse returns. These are the things to watch for: Are your variable names (column names) clean? All lowercase with _ separating words? Are dates saved in a date format? ship_date looks good at &lt;dttm&gt;, which means “datetime.” Are your numbers really numbers? acquisition_value is the column we are most concerned about here, and it looks good. This data set looks good (because I pre-prepared it fo you), but you always want to check and make corrections, like we did to fix the date in the Billboard assignment. 5.4.6 Remove unnecessary columns Sometimes at this point in a project, you might not know what columns you need to keep and which you could do without. The nice thing about doing this with code in a notebook is we can always go back, make corrections and run our notebook again. In this case, I’m going to tell you which columns you can remove so we have a tighter data set to work with. We’ll also learn a cool trick with select(). Start a new section with a headline, text to explain you are removing unneeded columns. Add a code chunk and the following code. I’ll explain it below. leso_tight &lt;- leso %&gt;% select( -sheet, -nsn, -starts_with(&quot;demil&quot;) ) leso_tight %&gt;% glimpse() ## Rows: 124,848 ## Columns: 8 ## $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;… ## $ agency_name &lt;chr&gt; &quot;ABBEVILLE POLICE DEPT&quot;, &quot;ABBEVILLE POLICE DEPT&quot;, &quot;A… ## $ item_name &lt;chr&gt; &quot;BALLISTIC BLANKET KIT&quot;, &quot;OPTICAL SIGHTING AND RANGI… ## $ quantity &lt;dbl&gt; 10, 1, 10, 9, 10, 1, 1, 1, 1, 1, 1, 1, 3, 12, 1, 5, … ## $ ui &lt;chr&gt; &quot;Kit&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each… ## $ acquisition_value &lt;dbl&gt; 15871.59, 245.88, 1626.00, 333.00, 926.00, 658000.00… ## $ ship_date &lt;dttm&gt; 2018-01-30, 2016-06-02, 2016-09-19, 2016-09-14, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… We did a select like this with billboard, but note the third item within the select(): -starts_with(\"demil\"). This removes both the demil_code and demil_ic columns in one move by finding all the columns that “start with ‘demil’.” The - before it negates (or removes) the columns. There are other special operators you can use with select(), like: ends_with(), contains() and many more. Check out the docs on the select function. So now we have a tibble called leso_tight that we will work with in the next section. 5.4.7 Create a total_value column When we used mutate() to convert the date in the Billboard assignment, we were reassigning values in each row of a column back into the same column. In this assignment, we will use mutate() to create a new column with new values based on a calculation (quantity multiplied by the acquisition_value) for each row. Let’s review the concept first. If you started with data like this: item item_count item_value Bread 2 1.5 Milk 1 2.75 Beer 3 9 And wanted to create a total value of each item in the table, you would use mutate(): data %&gt;% mutate(total_value = item_count * item_value) And you would get a return like this, with your new total_value column added at the end: item item_count item_value total_value Bread 2 1.5 3 Milk 1 2.75 2.75 Beer 3 9 27 Other math operators work as well: +, -, * and /. So, now that we’ve talked about how it is done, I want you to: Create a new section with headline, text and code chunk. Use mutate() to create a new total_value column that multiplies quantity times acquisition_value. Assign those results into a new tibble called leso_total so we can all be on the same page. Glimpse the new tibble so you can check the results. Try it on your own. You can figure it out! leso_total &lt;- leso_tight %&gt;% mutate( total_value = quantity * acquisition_value ) leso_total %&gt;% glimpse() ## Rows: 124,848 ## Columns: 9 ## $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;… ## $ agency_name &lt;chr&gt; &quot;ABBEVILLE POLICE DEPT&quot;, &quot;ABBEVILLE POLICE DEPT&quot;, &quot;A… ## $ item_name &lt;chr&gt; &quot;BALLISTIC BLANKET KIT&quot;, &quot;OPTICAL SIGHTING AND RANGI… ## $ quantity &lt;dbl&gt; 10, 1, 10, 9, 10, 1, 1, 1, 1, 1, 1, 1, 3, 12, 1, 5, … ## $ ui &lt;chr&gt; &quot;Kit&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each… ## $ acquisition_value &lt;dbl&gt; 15871.59, 245.88, 1626.00, 333.00, 926.00, 658000.00… ## $ ship_date &lt;dttm&gt; 2018-01-30, 2016-06-02, 2016-09-19, 2016-09-14, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… ## $ total_value &lt;dbl&gt; 158715.90, 245.88, 16260.00, 2997.00, 9260.00, 65800… Check that it worked!!. Use the glimpsed data to check the first item: For me, 10 * 15871.59 = 158715.90, which is correct! Note that new columns are added at the end of the tibble. That is why I suggested you glimpse the data instead of printing the tibble so you can easily see results on one screen. 5.4.8 Filtering our data You used filter() in the Billboard lesson to get No. 1 songs and to get a date range of data. We need to do something similar here to get only Texas data of a certain date range, but we’ll build the filters one at a time so we can check the results. 5.4.8.1 Apply the TX filter Create a new section with headlines and text that denote you are filtering the data to Texas and since Jan. 1, 2010 Create the code chunk and start your filter process using the leso_total tibble. Use filter() on the state column to keep all rows with “TX.” Really, you got this. leso_total %&gt;% filter( state == &quot;TX&quot; ) ## # A tibble: 8,663 × 9 ## state agency_name item_name quantity ui acquisition_val… ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 2 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 3 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 4 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 5 TX ABERNATHY POLICE DEPT RIFLE,5.56 MILLI… 1 Each 749 ## 6 TX ABERNATHY POLICE DEPT TRUCK,UTILITY 1 Each 62627 ## 7 TX ABERNATHY POLICE DEPT SIGHT,REFLEX 5 Each 333 ## 8 TX ABERNATHY POLICE DEPT RIFLE,5.56 MILLI… 1 Each 749 ## 9 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 10 TX ABILENE POLICE DEPT RIFLE,5.56 MILLI… 1 Each 499 ## # … with 8,653 more rows, and 3 more variables: ship_date &lt;dttm&gt;, ## # station_type &lt;chr&gt;, total_value &lt;dbl&gt; How do you know if it worked? Well the first column in the data is the state column, so they should all start with “TX.” Also note you started with nearly 130k observations (rows), and there are only 8,600+ in Texas. 5.4.8.2 Add the date filter Now, EDIT THAT SAME CHUNK to add a new part to your filter to also get rows with a ship_date of 2010-01-01 or later. If you do this on your own, treat yourself to a cookie leso_total %&gt;% filter( state == &quot;TX&quot;, ship_date &gt;= &quot;2010-01-01&quot; ) ## # A tibble: 7,411 × 9 ## state agency_name item_name quantity ui acquisition_val… ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 2 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 3 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 4 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 5 TX ABERNATHY POLICE DEPT RIFLE,5.56 MILLI… 1 Each 749 ## 6 TX ABERNATHY POLICE DEPT TRUCK,UTILITY 1 Each 62627 ## 7 TX ABERNATHY POLICE DEPT SIGHT,REFLEX 5 Each 333 ## 8 TX ABERNATHY POLICE DEPT RIFLE,5.56 MILLI… 1 Each 749 ## 9 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .… 1 Each 58.7 ## 10 TX ALLEN POLICE DEPT SIGHT,REFLEX 1 Each 333 ## # … with 7,401 more rows, and 3 more variables: ship_date &lt;dttm&gt;, ## # station_type &lt;chr&gt;, total_value &lt;dbl&gt; 5.4.8.3 Checking the results with summary() How do you know this date filter worked? Well, we went from 8600+ rows to 7400+ rows, so we did something. You might look at the results table and click over to the ship_date columns so you can see some of the results, but you can’t be sure the top row is the oldest. We could use an arrange() to test that, but I have another suggestion: summary(). Now, summary() is different than summarize(), which we’ll do plenty of in a minute. The summary() function will show you some results about each column in your data, and when it is a number or date, it will give you some basic stats like min, max and median values. Use the image below to add a summary() function to your filtering data chunk. Once you’ve confirmed that the “Min.” of ship_date is not older than 2010, then REMOVE THE SUMMARY STATEMENT. If you leave the summary statement there when we create our updated tibble, then you’ll “save” the summary and not the data. Summary function 5.4.8.4 Add filtered data to new tibble Once you’ve checked and removed the summary, you can save your filtered data into a new tibble. Edit the filtering chunk to put the results into a new tibble called leso_filtered. Seriously? You were going to look? leso_filtered &lt;- leso_total %&gt;% filter( state == &quot;TX&quot;, ship_date &gt;= &quot;2010-01-01&quot; ) leso_filtered %&gt;% glimpse() ## Rows: 7,411 ## Columns: 9 ## $ state &lt;chr&gt; &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;… ## $ agency_name &lt;chr&gt; &quot;ABERNATHY POLICE DEPT&quot;, &quot;ABERNATHY POLICE DEPT&quot;, &quot;A… ## $ item_name &lt;chr&gt; &quot;PISTOL,CALIBER .45,AUTOMATIC&quot;, &quot;PISTOL,CALIBER .45,… ## $ quantity &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ ui &lt;chr&gt; &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Eac… ## $ acquisition_value &lt;dbl&gt; 58.71, 58.71, 58.71, 58.71, 749.00, 62627.00, 333.00… ## $ ship_date &lt;dttm&gt; 2011-11-03, 2011-11-03, 2011-11-03, 2011-11-03, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… ## $ total_value &lt;dbl&gt; 58.71, 58.71, 58.71, 58.71, 749.00, 62627.00, 1665.0… 5.4.9 Export cleaned data Now that we have our data selected, mutated and filtered how we want it, we can export your leso_filtered tibble into an .rds file to use in our analysis notebook. If you recall, we use the .rds format because it will remember data types and such. Create a new section with headline and text explaining that you are exporting the data. Do it. The function you need is called write_rds and you need to give it a path/name that saves the file in the data-processed folder. Name it 01-leso-tx.rds so you know it a) came from the first notebook b) is the Texas only data. Well-formatted, descriptive file names are important to your future self and other colleagues. Try it leso_filtered %&gt;% write_rds(&quot;data-processed/01-leso-tx.rds&quot;) 5.5 Things we learned in this lesson This chapter was similar to when we imported data for Billboard, but we did introduce a couple of new concepts: starts_with() can be used within a select() function to select columns with similar names. There are also ends_with() and contains() and others. See the documentation on Select. summary() gives you descriptive statistics about your tibble. We used it to check the “min” date, but you can also see averages (mean), max and medians. "],["sums-analyze.html", "Chapter 6 Summarize with math - analysis 6.1 Learning goals of this lesson 6.2 Questions to answer 6.3 Set up the analysis notebook 6.4 How to tackle summaries 6.5 Looking a local agencies 6.6 Item quantities, totals for local agencies 6.7 Write a data drop 6.8 What we learned in this chapter", " Chapter 6 Summarize with math - analysis In the last chapter, we covered the overall story about the LESO data … that local law enforcement agencies can get surplus military equipment from the U.S. Department of Defense. We downloaded a pre-processed version of the data and filtered it to just Texas records over a specific time period (2010 to present), and used mutate() to create a new column calculated fron other variables in the data. 6.1 Learning goals of this lesson In this chapter we will start querying the data using summarize with math, basically using summarize to add values in a column instead of counting rows, which we did with the Billboard assignment. Our learning goals are: To use the combination of group_by(), summarize() and arrange() to add columns of data using sum(). To use different group_by() groupings in specific ways to get desired results. To practice using filter() on those summaries to better see certain results, including filtering within a vector (or list of strings). We’ll research and write about some of the findings, practicing data-centric ledes and sentences describing data. 6.2 Questions to answer A reminder of what we are looking for: All answers are be based on data from Jan. 1, 2010 to present for only consider Texas agencies. We did this filtering already. For each agency in Texas, find the summed quantity and summed total value of the equipment they received. (When I say “summed” that means we’ll add together all the values in the column.) Once you have the list, we’ll think about what stands out and why? We’ll take the list above, but filter that summary to show only the following local agencies: AUSTIN POLICE DEPT SAN MARCOS POLICE DEPT TRAVIS COUNTY SHERIFFS OFFICE UNIV OF TEXAS SYSTEM POLICE HI_ED WILLIAMSON COUNTY SHERIFF’S OFFICE For each of the agencies above we’ll use summarize to get the summed quantity and summed total_value of each item shipped to the agency. We’ll create a summarized list for each agency so we can write about each one. You’ll research some of the more interesting items the agencies received (i.e. Google the names) so you can include them in your data drop. 6.3 Set up the analysis notebook Before we get into how to do this, let’s set up our analysis notebook. Make sure you have your military surplus project open in RStudio. If you have your import notebook open, close it and use Run &gt; Restart R and Clear Output. Create a new RNotebook and edit the title as “Military surplus analysis.” Remove the boilerplate text. Create a setup section (headline, text and code chunk) that loads the tidyverse library. Save the notebook at 02-analysis.Rmd. We’ve started each notebook like this, so you should be able to do this on your own now. 6.3.1 Load the data into a tibble Next create an import section (headline, text and chunk) that loads the data from the previous notebook and save it into a tibble called tx. Add a glimpse() of the data for your reference. We did this in Billboard and you should be able to do it. You’ll use read_rds() and find your data in your data-processed folder. Remember your data is in data-processed tx &lt;- read_rds(&quot;data-processed/01-leso-tx.rds&quot;) tx %&gt;% glimpse() ## Rows: 7,411 ## Columns: 9 ## $ state &lt;chr&gt; &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;… ## $ agency_name &lt;chr&gt; &quot;ABERNATHY POLICE DEPT&quot;, &quot;ABERNATHY POLICE DEPT&quot;, &quot;A… ## $ item_name &lt;chr&gt; &quot;PISTOL,CALIBER .45,AUTOMATIC&quot;, &quot;PISTOL,CALIBER .45,… ## $ quantity &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ ui &lt;chr&gt; &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Eac… ## $ acquisition_value &lt;dbl&gt; 58.71, 58.71, 58.71, 58.71, 749.00, 62627.00, 333.00… ## $ ship_date &lt;dttm&gt; 2011-11-03, 2011-11-03, 2011-11-03, 2011-11-03, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… ## $ total_value &lt;dbl&gt; 58.71, 58.71, 58.71, 58.71, 749.00, 62627.00, 1665.0… You should see the tx object in you Environment. 6.4 How to tackle summaries As we get into the first quest, let’s talk about “how” we do summaries. When I am querying my data, I start by envisioning what the result should look like. Let’s take the first question: For each agency in Texas, find the summed quantity and summed total value of the equipment they received. Let’s break this down: “For each agency in Texas.” For all the questions, we only want Texas agencies. We took care of this in nthe import book so TX agencies should already filtered. But the “For each agency” part tells me I need to group_by the agency_name so I can summarize totals within each agency. “find the summed quantity and summed total_value”: Because I’m looking for a total (or sum() of columns) I need summarize(). So I envision my result looking like this: agency_name summed_quantity summed_total_value AFAKE POLICE DEPT 6419 10825707.5 BFAKE SHERIFF’S OFFICE 381 3776291.52 CFAKE SHERIFF’S OFFICE 270 3464741.36 DFAKE POLICE DEPT 1082 3100420.57 The first columns in that summary will be our grouped values. This example is only grouping by one thing, agency_name. The other two columns are the summed values I’m looking to generate. 6.4.1 Summaries with math We’ll start with the total_quantity. Add a new section (headline, text and chunk) that describes the first quest: For each agency in Texas, find the summed quantity and summed total value of the equipment they received. Add the code below into the chunk and run it. tx %&gt;% group_by(agency_name) %&gt;% summarize( sum_quantity = sum(quantity) ) ## # A tibble: 356 × 2 ## agency_name sum_quantity ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABERNATHY POLICE DEPT 13 ## 2 ALLEN POLICE DEPT 11 ## 3 ALVARADO ISD PD 4 ## 4 ALVIN POLICE DEPT 508 ## 5 ANDERSON COUNTY SHERIFFS OFFICE 7 ## 6 ANDREWS COUNTY SHERIFF OFFICE 12 ## 7 ANSON POLICE DEPT 9 ## 8 ANTHONY POLICE DEPT 10 ## 9 ARANSAS PASS POLICE DEPARTMENT 27 ## 10 ARCHER COUNTY SHERIFF OFFICE 3 ## # … with 346 more rows Let’s break this down a little. We start with the tx data, and then … We group by agency_name. This organizes our data (behind the scenes) so our summarize actions will happen within each agency. Now I normally say run your code one line at a time, but you would note be able to see the groupings, so I usually write group_by() and summarize() together. In summarize() we first name our new column: sum_quantity. We could call this whatever we want, but good practice is to name it what it is. We use good naming techniqes and split the words using _. I also use all lowercase characters. We set that column to equal = the sum of all values in the quantity column. sum() is the function, and we feed it the column we want to add together: quantity. I put the inside of the summarize function in its own line because we will add to it. I enhances readability. RStudio will help you with the indenting, etc. If you look at the first line of the return, it is taking all the rows for the “ABERNATHY POLICE DEPT” and then adding together all the values in the quantity field. If you wanted to test this (and it is a real good idea), you might look at the data from one of the values and check the math. Here are the Abernathy rows. I usually do these tests in a code chunk of their own, and sometimes I delete them after I’m sure it worked. tx %&gt;% filter(agency_name == &quot;ABERNATHY POLICE DEPT&quot;) ## # A tibble: 9 × 9 ## state agency_name item_name quantity ui acquisition_val… ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .4… 1 Each 58.7 ## 2 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .4… 1 Each 58.7 ## 3 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .4… 1 Each 58.7 ## 4 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .4… 1 Each 58.7 ## 5 TX ABERNATHY POLICE DEPT RIFLE,5.56 MILLIM… 1 Each 749 ## 6 TX ABERNATHY POLICE DEPT TRUCK,UTILITY 1 Each 62627 ## 7 TX ABERNATHY POLICE DEPT SIGHT,REFLEX 5 Each 333 ## 8 TX ABERNATHY POLICE DEPT RIFLE,5.56 MILLIM… 1 Each 749 ## 9 TX ABERNATHY POLICE DEPT PISTOL,CALIBER .4… 1 Each 58.7 ## # … with 3 more variables: ship_date &lt;dttm&gt;, station_type &lt;chr&gt;, ## # total_value &lt;dbl&gt; If we look at the quantity column there and eyeball all the rows, we see there 8 rows with a value of “1,” and one row with a value of “5.” 8 + 5 = 13, which matches our sum_quantity answer in our summary table. We’re good! 6.4.2 Add the total_value We don’t have to stop at one summary. We can perform multiple summarize actions on the same or different columns within the same expression. Edit your summary chunk to: Add add a comma after the first summarize action. Add the new expression to give us the sum_total_value and run it. tx %&gt;% group_by(agency_name) %&gt;% summarize( sum_quantity = sum(quantity), sum_total_value = sum(total_value) ) ## # A tibble: 356 × 3 ## agency_name sum_quantity sum_total_value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ABERNATHY POLICE DEPT 13 66084. ## 2 ALLEN POLICE DEPT 11 1404024 ## 3 ALVARADO ISD PD 4 480 ## 4 ALVIN POLICE DEPT 508 2504765. ## 5 ANDERSON COUNTY SHERIFFS OFFICE 7 733720 ## 6 ANDREWS COUNTY SHERIFF OFFICE 12 1476 ## 7 ANSON POLICE DEPT 9 5077 ## 8 ANTHONY POLICE DEPT 10 7490 ## 9 ARANSAS PASS POLICE DEPARTMENT 27 503658 ## 10 ARCHER COUNTY SHERIFF OFFICE 3 1101000 ## # … with 346 more rows 6.4.3 Arrange the results OK, this gives us our answers, but in alphabetical order. We want to arrange the data so it gives us the most sum_total_value in descending order. EDIT your block to add an arrange() function below tx %&gt;% group_by(agency_name) %&gt;% summarize( sum_quantity = sum(quantity), sum_total_value = sum(total_value) ) %&gt;% arrange(sum_total_value %&gt;% desc()) ## # A tibble: 356 × 3 ## agency_name sum_quantity sum_total_value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 HOUSTON POLICE DEPT 5467 9140513. ## 2 JEFFERSON COUNTY SHERIFFS OFFICE 270 3464365. ## 3 DPS SWAT- TEXAS RANGERS 1461 3317967. ## 4 PARKS AND WILDLIFE DEPT 9306 3236996. ## 5 SAN MARCOS POLICE DEPT 1050 3090552. ## 6 HARRIS COUNTY SHERIFF&#39;S OFFICE 835 2941507. ## 7 AUSTIN POLICE DEPT 1438 2732120. ## 8 ALVIN POLICE DEPT 508 2504765. ## 9 MILAM COUNTY SHERIFF DEPT 99 2469525. ## 10 HARRIS COUNTY CONSTABLE PCT 3 292 2376779. ## # … with 346 more rows 6.4.4 Consider the results Is there anything that sticks out in that list? It helps if you know a little bit about Texas cities and counties, but here are some thoughts to ponder: Houston is the largest city in the state (4th largest in the country). It makes sense that it tops the list. Same for Harris County or even the state police force. Austin being up there is also not crazy, as it’s almost a million people. But what about San Marcos (63,220)? Or Milam County (24,770)? Those are way smaller cities and law enforcement agencies. They might be worth looking into. Perhaps we should look some at the police agencies closest to us. 6.5 Looking a local agencies Our next goal is this: We’ll take the summary above, but filter it to show only some local agencies of interest. Since we are essentially taking an existing summary and adding more filtering to it, it makes sense to go back into that chunk and save it into a new object so we can reuse it. EDIT your existing summary chunk to save it into a new tibble. Name it tx_quants_totals so we are all on the same page. Add a new line that prints the result to the screen so you can still see it. # adding the new tibble object in next line tx_quants_totals &lt;- tx %&gt;% group_by(agency_name) %&gt;% summarize( sum_quantity = sum(quantity), sum_total_value = sum(total_value) ) %&gt;% arrange(sum_total_value %&gt;% desc()) # peek at the result tx_quants_totals ## # A tibble: 356 × 3 ## agency_name sum_quantity sum_total_value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 HOUSTON POLICE DEPT 5467 9140513. ## 2 JEFFERSON COUNTY SHERIFFS OFFICE 270 3464365. ## 3 DPS SWAT- TEXAS RANGERS 1461 3317967. ## 4 PARKS AND WILDLIFE DEPT 9306 3236996. ## 5 SAN MARCOS POLICE DEPT 1050 3090552. ## 6 HARRIS COUNTY SHERIFF&#39;S OFFICE 835 2941507. ## 7 AUSTIN POLICE DEPT 1438 2732120. ## 8 ALVIN POLICE DEPT 508 2504765. ## 9 MILAM COUNTY SHERIFF DEPT 99 2469525. ## 10 HARRIS COUNTY CONSTABLE PCT 3 292 2376779. ## # … with 346 more rows The result is the same, but we can reuse the tx_quants_totals tibble. 6.5.1 Filtering within a vector Let’s talk through the filter concepts before you try it with this data. When we talked about filtering with the Billboard project, we discussed using the | operator as an “OR” function. If we were to apply that logic here, it would look like this: data %&gt;% filter(column_name == &quot;Text to find&quot; | column_name == &quot;More text to find&quot;) That can get pretty unwieldy if you have more than a couple of things to look for. There is another operator %in% where we can search for multiple items from a list. (This list of terms is officially called a vector, but whatever.) Think of it like this in plain English: Filter the column for things in this list. data %&gt;% filter(col_name %in% c(&quot;This string&quot;, &quot;That string&quot;)) We can take this a step further by saving the items in our list into an R object so we can reuse that list and not have to type out all the terms each time we use them. list_of_strings &lt;- c( &quot;This string&quot;, &quot;That string&quot; ) data %&gt;% filter(col_name %in% list_of_strings) 6.5.2 Use the vector to build this filter Create a new section (headline, text and chunk) and describe you are filtering the summed quantity/values for some select local agencies. Create a saved vector list (like the list_of_strings above) of the five agencies we want to focus on. Call it local_agencies. Start with the tx_quants_totals tibble you created for totals by agency and then use filter() and %in% to filter by your new local_agencies list. These are the agencies: AUSTIN POLICE DEPT SAN MARCOS POLICE DEPT TRAVIS COUNTY SHERIFFS OFFICE UNIV OF TEXAS SYSTEM POLICE HI_ED WILLIAMSON COUNTY SHERIFF&#39;S OFFICE To be clear, in the interest of time I’ve done considerable work beforehand to figure out the exact names of these agencies. It helps that I’m familiar with local cities and counties so I used some creative filtering to find their “official” names in the data. I just don’t want to get into how right now. Use the example above to build with your data local_agencies &lt;- c( &quot;AUSTIN POLICE DEPT&quot;, &quot;SAN MARCOS POLICE DEPT&quot;, &quot;TRAVIS COUNTY SHERIFFS OFFICE&quot;, &quot;UNIV OF TEXAS SYSTEM POLICE HI_ED&quot;, &quot;WILLIAMSON COUNTY SHERIFF&#39;S OFFICE&quot; ) tx_quants_totals %&gt;% filter(agency_name %in% local_agencies) ## # A tibble: 5 × 3 ## agency_name sum_quantity sum_total_value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 SAN MARCOS POLICE DEPT 1050 3090552. ## 2 AUSTIN POLICE DEPT 1438 2732120. ## 3 UNIV OF TEXAS SYSTEM POLICE HI_ED 3 1305000 ## 4 TRAVIS COUNTY SHERIFFS OFFICE 151 935774. ## 5 WILLIAMSON COUNTY SHERIFF&#39;S OFFICE 205 429784. 6.6 Item quantities, totals for local agencies Now that we have an overall idea of what local agencies are doing, let’s dive a little deeper. It’s time to figure out the specific items that they received. Here is the quest: For each of the agencies above we’ll use summarize to get the summed quantity and summed total_value of each item shipped to the agency. We’ll create a summarized list for each agency so we can write about each one. In some cases an agency might get the same item shipped to them at different times. For instance, APD has multiple rows of a single “ILLUMINATOR,INTEGRATED,SMALL ARM” shipped to them on the same date, and at other times the quantity is combined as 30 items into a single row. We’ll group our summarize by item_name so we can get the totals for both quantity and total_value for like items. Create a new section (headline, text and first code chunk) and describe that you are finding the sums of each different item the agency has received since 2010. Our first code chunk will start with the tx data, and then filter the results to just “AUSTIN POLICE DEPT.” Use group_by to group by item_name. Use summarize to build the summed_quantity and summed_total_value columns. Arrange the results so the most expensive items are at the top. tx %&gt;% filter(agency_name == &quot;AUSTIN POLICE DEPT&quot;) %&gt;% group_by(item_name) %&gt;% summarize( summed_quantity = sum(quantity), summed_total_value = sum(total_value) ) %&gt;% arrange(summed_total_value %&gt;% desc()) ## # A tibble: 41 × 3 ## item_name summed_quantity summed_total_val… ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 HELICOPTER,FLIGHT TRAINER 1 833400 ## 2 IMAGE INTENSIFIER,NIGHT VISION 85 467847. ## 3 SIGHT,THERMAL 29 442310 ## 4 PACKBOT 510 WITH FASTAC REMOTELY CONTROLLE… 4 308000 ## 5 SIGHT,REFLEX 420 144245. ## 6 ILLUMINATOR,INTEGRATED,SMALL ARMS 135 122302 ## 7 RECON SCOUT XT 8 92451. ## 8 RECON SCOUT XT,SPEC 6 81900 ## 9 TEST SET,NIGHT VISION VIEWER 2 55610 ## 10 PICKUP 2 38075 ## # … with 31 more rows Please realize that this combines items that may have been shipped on any date our time period. If you want to learn more about when they got the items, you would have to build a new list of the data without grouping/summarizing. 6.6.1 Build the lists for other agencies On your own … Build a similar list for all the other local agencies. Basically you are just changing the filtering. You should end up with five chunks, each summarizing a different agency. 6.6.2 Google some interesting items You’ll want some more detail in your data drop about some of these specific items. Do some Googling on some of these items of interest to learn more about them. I realize (and you should, too) that for a “real” story we would need to reach out to sources for more information, but you can get a general idea from what you find online for the writing assignment below. 6.7 Write a data drop Once you’ve found answers to all the questions listed, you may be asked to use that information in a writing assignment. See Canvas for details. 6.8 What we learned in this chapter We used sum() within a group_by()/summarize() function to add values within a column. We used summary() to get descriptive statistics about our data, like the minimum and maximum values, or an average (mean). We learned how to use c() to combine a list of like values into a vector, and then used that vector to filter a column for valus %in% that vector. "],["ggplot-intro.html", "Chapter 7 Data Viz - Intro to ggplot 7.1 Goals for this section 7.2 Introduction to ggplot 7.3 Start a new project 7.4 The layers of ggplot 7.5 Let’s build a bar chart 7.6 On your own: Ice cream! 7.7 What we’ve learned", " Chapter 7 Data Viz - Intro to ggplot The chapter is by Prof. Lukito, who uses a PC. This week, we’ll move on from summaries to talking about data visualizations (“data viz”), an essential skill for any data journalist. While there are a lot of different ways to make figures and graphs, this chapter will focus on one popular R package for data viz: ggplot. 7.1 Goals for this section In this chapter, we’ll learn the basics of data visualization using the Grammar of Graphics principles. We’ll start with some smaller datasets to give you a sense of how the code works. And, in the next chapter, you’ll apply this to a dataset we have already used in the class. Our learning goals are: To learn about the Grammar of Graphics To make scatterplots To make bar charts 7.2 Introduction to ggplot ggplot2 is the data visualization library within Hadley Wickham’s tidyverse. It is a beast of a package, because it supports a whole variety of different types of data visualizations, from bar charts and line charts to fancy choropleth maps and animated figures. Even though the package is called ggplot2, the function to make graphs is just ggplot(). So, for simplicity, we’ll just call everything ggplot The ggplot package relies on a concept called the Grammar of Graphics, hence the gg in ggplot. The basic logic of the Grammar of Graphics is that any graph you could ever want to build will need similar things: a data set, some information about the scales of your variables, and the type of figure or graph that you want to create. These various things can be “layered” on top of each other to create a visually pleasing graph. Folks who have used Adobe creative programs (e.g., Photoshop, Illustrator, etc.) can think about it like laying an image: each layer in your image should do something to change the image. Likewise, each layer in a ggplot figure will add to the overall graph. 7.2.1 What I like/dislike about ggplot Let me just start by saying that I’m a total ggplot geek. I’ll talk about ggplot figures the way people talk about new TikTok trends. When producing figures and graphs in R, ggplot is the absolute best approach because you’ll see the results right in your R notebook. And, basic data visualizations are an absolutely essential skill for any data journalist: it helps you find important things in your data that you may ultimately report on. So, ggplot is important for any R-based data journalism project. That being said, there are less complicated ways of creating publishable graphics. Tools like Datawrapper and Flourish can produce equally beautiful graphics without the code. So why learn ggplot? Because, (1) ggplot is super useful when you’re just learning about the data and (2) to get good enough in ggplot to make publishable graphics, you have to practice, practice, practice. Yes, ggplot is a big package with lots of nuiance. But the more you take the time to learn it, the more you will master it. 7.2.2 The Grammar of Graphics This section was inspired by Matt Waite and the BBC Visual Cookbook. As I said above, the gg in ggplot stands for “Grammar of Graphics,” which is a fancy way of saying we’ll build our charts layer by layer. Once you know what data you are using, there are three main layers to any ggplot chart: aesthetics (“aes”): this is where you put information about the dataset, including specifics about what fields/variables should be on the x-axis and y-axis. geometries (“geom”): this is where you tell R the shape of your visualization, whether it’s lines, bars, points, or something else. themes (“theme”): this is where you tell R the font you’d like to use, the background color, and other things you want to “pretty up” the data viz. In addition to these three main layers, there are lots of helper layers we’ll learn about along the way, including: coord_flip: a special layer for flipping the chart scales: transforming the data to make the plot more read-able labels (“labs”): for making titles and labels facets: For graphing many elements of the same data set in the same space (one dataset, multiple figures) This all may seem complicated now, but it’ll make sense once we start putting together these layers together, one at a time. After all, the best way to learn any R package is to do it 7.3 Start a new project Get into RStudio and make sure you don’t have any other files or projects open. Create a new project, name it yourname-ggplot and save it in your rwd folder. (No need for a folder structure, we’ll do this all in one file.) Start a new RMarkdown notebook and save it as 01-intro-ggplot.Rmd. Remove the boilerplate and create a setup section that loads library(tidyverse), like we do with every notebook. The ggplot package is a part of tidyverse, so when you load tidyverse, you’ll load ggplot. 7.4 The layers of ggplot Much of this first plot explanation comes from Hadley Wickham’s R for Data Science, with edits to fit the lesson here. To explore how ggplot works, we’re going to work with some data that already comes with tidyverse. Let’s take a look at it now. Start a new section “First plot” and add a code chunk. Add the code below and run it to see what the mpg dataset looks like. mpg ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows The mpg data contains observations collected by the US Environmental Protection Agency on 38 models of cars. It’s a data set embedded into the tidyverse for lessons like this one. For this lesson, we’ll use (at least two) two specific variables in this data: displ, a car’s engine size, in liters. hwy, a car’s fuel efficiency on the highway, in miles per gallon (mpg). With these two variables, we can test the theory that cars with smaller engines (displ) get better gas mileage (hwy). To do this, we’ll make a plot. 7.4.1 Build the base layer When working with the ggplot2 package, you’ll start nearly every figure with the ggplot() function. In the ggplot() function, you’ll tell R what data you’re using, and the coordinate system you want to build based on the data. The first thing you’ll want to do is tell ggplot the dataset you want to use (in this case, mpg). Let’s do that now. Do this: In your first plot section, add some text that you are building the mpg chart. Make a new code chunk and add the code below. ggplot(mpg) This tells us… absolutely nothing! But that’s not surprising: you haven’t even told ggplot what variables you want to focus on or the way you want to visualize the data. To do that, you’ll need a second argument (and the first official layer in your plot): the aes() (short for “aesthetic”). This is considered a mapping argument, because you use this argument to tell ggplot how you want to map your data (in our case, mpg). In an aes() argument, you want to indicate the variables that you will be mapping to the x and y axes. This is usually done with the x and y arguments, so your aes() argument will look something like this: aes(x = some_variable, y = another_variable), where some_variable and another_variable are variables in your dataset. In our case, we’ll practice using displ (the car’s engine size) and hwy (the car’s highway efficiency). Let’s plug in our aes() layer now, directly into the ggplot() function. Do this: In the code chunk you created above, add the following line of code. ggplot(mpg, aes(x = displ, y = hwy)) Let’s work through the code above: ggplot() is the function we use to make a chart. The first argument ggplot() needs is the data. It could be specified as data = mpg but we don’t need the data = part as it is always the first item specified inside of (or piped into) ggplot() Next is the aesthetics or aes(). This is where tell ggplot what data to plot on the x and y axis. You might see this as mapping = aes(&lt;VALUES&gt;) but we can often get by without the mapping = part. This code tells us just a little bit more than nothing: instead of a blank box, we can now see the grid for the x and y axis. But we’ll need another layer to add data to this grid! A quick FYI: The aes() that you put into ggplot() apply to the whole graph. Other (geom) layers that you write after this main layer can also take aes() arguments. We’ll do that in future charts. Now that we have our ggplot() argument and first layer done, let’s talk about how to add layers to this. 7.4.2 Layers can we add to our plots Our base layer is the starting point for every ggplot chart, but it’s certainly not the end. In the next section below, we’ll work with three types of layers. Don’t worry if this seems like a lot of information: we’ll go layer by layer so you can see the whole process. Below are some of the layers we will work with: geometries (or “geoms” as we call them) are the way we plot data on the base grid. There are many geoms, but here are a few common ones: geom_points() adds dots onto the grid based on the data. Will will use these here to build a scatterplot graph. geom_line() adds lines between data points on the grid. Basically a line chart. geom_col() and geom_bars() adds bars to the grid based on values in the data. A bar chart. We’ll use geom_col() later in this lesson but you can read about the difference between the two in a later chapter. geom_text() adds labels based on values in the data. themes change the visual styles of the grids and axis. There are several available within ggplot and many other from the R community. labels (or labs, since we use the labs() function for them) are a series of text-based items we can layer onto our plots like titles, bylines and axis names. In addition to these layers, we’ll use the + at the end of each line. Think of the + as the %&gt;% of ggplot. So, your code will look something like this (don’t run this code chunk!): ggplot(data, aes(x = some_variable, y = another_variable)) + #creates the base layer, with the + at the end geom_layer #adds a geom Okay, now that we know what the code looks like, let’s proceed with the first geom. 7.4.3 Add geom_points The second layer we’ll add to our figure is a geom layer. “Geom” is short for geometries: these layers provide a lot of different ways to shape and visualize the data. Simply put, geom layers tell R what kind of chart you’d like to make. Let’s start with a straightforward geom layer, geom_plot(), which adds a layer of points to your plot (this type of plot is called a scatterplot). EDIT your plot chunk to add the + and a new line for geom_point() ggplot(mpg, aes(x = displ, y = hwy)) + # don&#39;t forget the + at the end of this line geom_point() # the geom_point layer #The geom_point() function will inherit the aes() values from the line above it. Now we’re starting to get somewhere! With the geom_point() layer added, our data are now finally displayed as points. And, as you can see, the pattern is pretty obvious: the lower the car’s displ (their engine size, in liters), the higher the hwy (their gas milage on a highway). 7.4.4 Adding other mappings As mentioned in the above section, there are aesthetics (aes) arguments that can apply to the plot as a whole (which we did with the x and y values above) and there are aesthetics we can write into specific geom layers (these aesthetics will not apply to other layers–just that geom). This can be useful if you wanted to incorporate a third variable into your figure, as we will demonstrate below, using color. Edit your geom_point() function to add a color mapping to the points with aes(color = class). color is the type of aesthetic, and class is another variable (column) in the data. ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) # this is the line you are editing As you can see, the dots were given colors based on the values in the class column, and ggplot also added a legend to the graphic. These colors are the default color settings in ggplot There are other aesthetics you can use. Change the color aesthetic to one of these values and run it to see how it affects the chart: alpha, size and shape. (i.e., alpha = class.) Once you’ve tried them, change it back to color. OK, enough of the basics … let’s build a chart you might care about. 7.5 Let’s build a bar chart In our first week of class, we sent out a survey where you told us your favorite Disney Princess and favorite flavor of ice cream. Let’s now play around with some of this data. For this lesson, we’re not going to create a different notebook or download the data to our computer. Instead, we’re going to save the data directly into a tibble. Start a new section: Princess chart data upload. In the text, note that we are importing the princess chart data. Add the code below to get the data. # read the data and create an tibble object called &quot;class&quot; class &lt;- read_csv(&quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vQfwR6DBW5Qv6O5aEBFJl4V8itnlDxFEc1e_-fOAtBMDxXx1GeEGb8o5VSgi33oTYqeFhVCevGGbG5y/pub?gid=0&amp;single=true&amp;output=csv&quot;) ## Rows: 28 Columns: 3 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (3): Name, Princess, Ice cream ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # peek at the data class ## # A tibble: 28 × 3 ## Name Princess `Ice cream` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Katy Belle (Beauty and the Beast) Cookies and Cream ## 2 Ana Belle (Beauty and the Beast) Cookie Dough ## 3 Marissa Tiana (Princess and the Frog) Cookie Dough ## 4 Jessie Pocahontas Strawberry ## 5 José Ariel (Little Mermaid) Cookies and Cream ## 6 Claire Ariel (Little Mermaid) Coffee/Jamoca ## 7 Payne Snow White Cookie Dough ## 8 Caro Belle (Beauty and the Beast) Cookie Dough ## 9 Vicente Rapunzel (Tangled) Coffee/Jamoca ## 10 Bryan Jasmine (Aladdin) Cookie Dough ## # … with 18 more rows So, now, you should have the data in your environment. 7.5.1 Prepare the data While there are ways for ggplot to calculate values from your data on the fly, I prefer to first build a table of the values I want, and then I will plot it on a chart. It’s helpful to think of these steps as separate so you have a good workflow (clean the data, prepare the data in a table form, and then plot the data). Today, our goal will be to make a bar chart, sometimes known as a column chart or histogram. This bar chart will show the number of votes for each princess from the data. So, we need to count the number of rows for each value … our typical group_by/summarize/arrange (GSA) process. For this lesson, I’m going to use the count() shortcut, since we haven’t used it much lately. Next, I’ll save the summarized data into a new dataframe called princess_data. Follow along in your notebook: Add a section: Princess chart. Add text that you are creating a data frame to plot. Add the code below to create that data. princess_data &lt;- class %&gt;% clean_names() %&gt;% #remember, this is from the janitor packae! count(princess, name = &quot;votes&quot;, sort = TRUE) # this above line counts the princess rows, sets the name and sorts # peek at the data princess_data ## # A tibble: 11 × 2 ## princess votes ## &lt;chr&gt; &lt;int&gt; ## 1 Ariel (Little Mermaid) 5 ## 2 Belle (Beauty and the Beast) 4 ## 3 Tiana (Princess and the Frog) 4 ## 4 Mulan 3 ## 5 Rapunzel (Tangled) 3 ## 6 Cinderella 2 ## 7 Jasmine (Aladdin) 2 ## 8 Snow White 2 ## 9 Aurora (Sleeping Beauty) 1 ## 10 Merida (Brave) 1 ## 11 Pocahontas 1 At this point, y’all should be plenty familiar with these summary functions, and the output should be easy to interpret: we’re just countin the number of rows for each princess. Now that we have our table data, let’s actually plot it. 7.5.2 Build our plot with geom_col Like in the previous lesson, we’ll start our plot by creating the first layer: the ggplot() function, which takes the data as its first argument and the aes() mapping layer as its second argument. Add some text noting that you’ll now plot. Add the following code chunk, which is the first layer ggplot(princess_data, aes(x = princess, y = votes)) # sets our x and y axes You’ll see the grid and x/y axis of the data, but no geometries are applied yet, so you won’t see any data. But remember, we’re adding these all in gradual layers. 7.5.3 Add the geom_col layer Now it is time to add our columns. To do this, we’ll use geom_col(). Similar to geom_point(), geom_col() adds a geometric layer that tells R how to display the data (in this case, with columns as opposed to points). Let’s write this code now. Edit the plot code to add the ggplot pipe + and on the next line add geom_col(). ggplot(princess_data, aes(x = princess, y = votes)) + # don&#39;t forget the + on this line geom_col() # adds the bars Our two-layer chart is getting somewhere now. We’re able to see the data in the plot, but there are a couple issues: We can’t read the value names. We can fix this. The order of the bars is alphabetical instead of in vote order. Again, we can fix it. 7.5.4 Flip the axes One way to fix the labels is to “flip” the axes, so the x axis becomes the y axis and vice versa. This is the equivalent of rotating the whole figure. When we do this, the axis will turn sideways, making it easier to read the labels. Worth noting: this can be a bit confusing later because the “x” axis is now going up/down (as opposed to left and right). Let’s learn how to flip the axes now. We’ll do this by adding a new layer, coord_flip(), which is a special layer that flips the axes. Just like we added the previous geom_col() layer using +, we’ll do the same thing here. Let’s do that now. Edit your plot chunk to add the ggplot pipe +and coord_flip() on the next line. ggplot(princess_data, aes(x = princess, y = votes)) + geom_col() + # don&#39;t forget the + coord_flip() # flips the axis As you can see, rather than having vertical bars, we now have horizontal bars, and the names of each princess are fully displayed and read-able. Much better! But the bars are still in an alphabetical order, as opposed to a vote order, so let’s fix that now. 7.5.5 Reorder the bars The bars on our chart are in alphabetical order of the x axis (and reversed thanks to our flip.) We want to order the values based on the votes in the data. Complication alert: Categorical data can have factors, which are like an internal ordering system. Some categories, like months in a year, have an “order” that is not alphabetical. We can reorder our categorical values in a plot by editing the x values in our aes() using reorder(). (There is a tidyverse function called fct_reorder() that works the same way. reorder() takes two arguments: The column to reorder, and the column to base that reorder on. It can happen in two different ways, and I’ll be honest and say I don’t know which is easier to comprehend. x = reorder(princess, votes) says “set the x axis as princess, but order as votes. OR … x = princess %&gt;% reorder(votes) says “set the x axis as princess and then reorder by votes. They both work. Even though I’m a fan of the tidyverse %&gt;% construct, I’m going with the first version. Edit the first line of your chunk to reorder the bars. ggplot(princess_data, aes(x = reorder(princess, votes), y = votes)) + # this is the line you edit geom_col() + coord_flip() So now, our princess names are read-able, and the bars are organized in vote size. But what if we wanted to be clearer in our figure, so that we knew the exact number of votes for each princess? Let’s learn how to add this information. 7.5.6 Adding a geom_text layer Now, we’re really starting to take advance of the grammar of graphics by including more than one geometric layer. Specifically, we’ll be using geom_text() to add some information to our bar charts. As we mentioned previously, geom layers can take individual aesthetics (that build on top of the global aesthetics you put in the first layer). When using geom_text(), we’ll include some local aesthetics using the aes() argument, to tell ggplot the label we’d like to add to the plot. Edit your plot chunk to add the ggplot pipe +and geom_text() on the next line. Add the following line to the chunk geom_text(aes(label = votes). ggplot(princess_data, aes(x = reorder(princess, votes), y = votes)) + geom_col() + coord_flip() + # don&#39;t forget + geom_text(aes(label = votes)) # plots votes text values on chart Well that did… something. We’ve successfully added the numbers to this plot, but it’s not very pretty. First, the number sits at the end of the bar, making it harder to read. So we’ll want to horizontally adjust this by shifting the numbers a bit to the left. Second, black text is really hard to read against a dark grey background. So we’ll change the text of the number to white. We can make both of these edits directly in the geom_text layer. Edit the last line of your plot chunk to add two new arguments. The first argument you will add is hjust, which moves the text left. (hjust stands for horizontal justification. vjust, or vertical justification, would move it up and down). The second argument you will add is color, which tells ggplot what the color of your text should be. As a reminder, you should always separate your arguments within a function using commas (,). ggplot(princess_data, aes(x = reorder(princess, votes), y = votes)) + geom_col() + coord_flip() + # don&#39;t forget + geom_text(aes(label = votes), hjust = 2, color = &quot;white&quot;) # plots read-able votes text values on chart Great! But we’re still not done. Even though we’ve added labels to each bar chart, we still haven’t added a title, and the titles of our x and y axes are not great. So let’s work on those now. 7.5.7 Add some titles and more labels Now that we have a chart, with some information displayed in bars, flipped and arranged so we can see information, let’s add to this by giving the chart some labels. We’ll do this by adding a layer of labels to our chart using the the labs() function. We can add and change a number of things with labs(), including creating a title, and changing the x and y axis titles. Edit the last line of your plot chunk to add the ggplot pipe + and labs() in the next line. Add a title using the title = argument Add a subtitle using the subtitle = argument. This is a great place to put information about your data (like when it was collected). Add a caption using the caption = argument. Put your byline here! Change the x and y axes titles using x = and y =. ggplot(princess_data, aes(x = reorder(princess, votes), y = votes)) + geom_col() + coord_flip() + # don&#39;t forget + geom_text(aes(label = votes), hjust = 2, color = &quot;white&quot;) + # plots votes text values on chart # labs below has several settings labs( title = &quot;Favored princess&quot;, # adds a title subtitle = &quot;Disney Princess votes from Reporting with Data, Spring 2022.&quot;, # adds a subtitle caption = &quot;By Jo Lukito&quot;, # adds the byline, replace this name with your own x = &quot;Princess choices&quot;, # renames the x axis label (which is really y since it is flipped) y = &quot;Number of votes&quot; # renames the y axis label (which is really x since it is flipped) ) There you go! You’ve made a chart showing how our classes rated Disney Princesses. 7.6 On your own: Ice cream! Now it is time for you to put these skills to work: Build a chart about the favorite ice creams from RWD classes. Some things to consider: You need a new section, etc. You’re starting with the same class data You need to prepare the data based on ice_cream (which is the name of a variable in your class data frame) You need to build the chart It’s essentially the same process we used for the princess chart, but using ice_cream variable. 7.7 What we’ve learned There is a ton, really. ggplot2 (which is really the ggplot() function) is the charting library for the tidyverse. This whole lesson was about it. Here are some more references for ggplot: The ggplot2 documentation and ggplot2 cheatsheets. R for Data Science, Chap 3. Hadley Wickam dives right into plots in his book. R Graphics Cookbook has lots of example plots. Good to harvest code and see how to do things. The R Graph Gallery another place to see examples. "],["ggplot-more.html", "Chapter 8 Deeper into ggplot 8.1 References 8.2 Learning goals for this chapter 8.3 Set up your notebook 8.4 Wrangle the data 8.5 Make a line chart of the Texas data 8.6 Themes 8.7 Adding more information 8.8 On your own: Line chart 8.9 Tour of some other adjustments 8.10 Facets 8.11 On your own: Facet wrap 8.12 Saving plots 8.13 Interactive plots 8.14 What we learned", " Chapter 8 Deeper into ggplot The chapter is by Prof. Lukito, who uses a PC. In the last chapter, you were introduced to ggplot2, the tidyverse package that helps you build graphics, charts, and figures. In this chapter, we’ll take your ggplot knowledge to the next level. We encourage you to treat this chapter as a reference. 8.1 References ggplot2 has a LOT to it and we’ll cover only the basics. Here are some references you might use: ggplot cheatsheet R for Data Science R Graphics Cookbook The R Graph Gallery another place to see examples. ggplot2: Elegant graphics for Data Analysis 8.2 Learning goals for this chapter In this chapter, we will cover the following topics: How to prepare and build a line chart How to use themes to change the looks of al chart More about aesthetics in layers! Faceting, or making multiple charts from the same data How to save files How to make interactive plots with Plotly 8.3 Set up your notebook This week, we’ll return to our leso data, but start a new RNotebook. Let’s open our “yourname-military-surplus” R project first, and then create a new Rmarkdown. Do this: Create your RNotebook. Rename the title “Military Surplus figures” Remove the rest of the boilerplate template. Save the file and name it 03-ggplot.Rmd. Load the tidyverse library. We’ll also load the lubridate package, which we used previously. 8.3.1 Let’s get the data We’ll demonstrate this in class, but you can also follow along in the screencast. Next, let’s read in the leso.csv dataset, which we imported in 5.4.4. We’ll do this using read_csv(). You should be able to do this on your own. Really! leso &lt;- read_csv(&quot;data-raw/leso.csv&quot;) #read the data in ## Rows: 124848 Columns: 12 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (7): state, agency_name, nsn, item_name, ui, demil_code, station_type ## dbl (4): sheet, quantity, acquisition_value, demil_ic ## dttm (1): ship_date ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. glimpse(leso) #peek at the data ## Rows: 124,848 ## Columns: 12 ## $ sheet &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;… ## $ agency_name &lt;chr&gt; &quot;ABBEVILLE POLICE DEPT&quot;, &quot;ABBEVILLE POLICE DEPT&quot;, &quot;A… ## $ nsn &lt;chr&gt; &quot;2540-01-565-4700&quot;, &quot;1240-DS-OPT-SIGH&quot;, &quot;1005-01-587… ## $ item_name &lt;chr&gt; &quot;BALLISTIC BLANKET KIT&quot;, &quot;OPTICAL SIGHTING AND RANGI… ## $ quantity &lt;dbl&gt; 10, 1, 10, 9, 10, 1, 1, 1, 1, 1, 1, 1, 3, 12, 1, 5, … ## $ ui &lt;chr&gt; &quot;Kit&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each… ## $ acquisition_value &lt;dbl&gt; 15871.59, 245.88, 1626.00, 333.00, 926.00, 658000.00… ## $ demil_code &lt;chr&gt; &quot;D&quot;, &quot;D&quot;, &quot;D&quot;, &quot;D&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;Q&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C… ## $ demil_ic &lt;dbl&gt; 1, NA, 1, 1, 1, 1, 1, 3, 7, 1, 1, NA, 1, 1, 1, 1, 1,… ## $ ship_date &lt;dttm&gt; 2018-01-30, 2016-06-02, 2016-09-19, 2016-09-14, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… Don’t forget to also do the other processing steps we did in Chapter 5. Again, you should be able to do this on your own Buuuut, if you needed a refresher, check out section 5.4.6 to 5.4.7. There are 2 steps to this: Removing unnecessary columns using select() Creating a total_value column using mutate() leso_tight &lt;- leso %&gt;% select( -sheet, -nsn, -starts_with(&quot;demil&quot;) ) #this chunk removes unnecessary columns leso_total &lt;- leso_tight %&gt;% mutate(total_value = quantity * acquisition_value) #this chunk creates a total_value column Alrighty! Let’s look at the data leso_total %&gt;% glimpse() ## Rows: 124,848 ## Columns: 9 ## $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;… ## $ agency_name &lt;chr&gt; &quot;ABBEVILLE POLICE DEPT&quot;, &quot;ABBEVILLE POLICE DEPT&quot;, &quot;A… ## $ item_name &lt;chr&gt; &quot;BALLISTIC BLANKET KIT&quot;, &quot;OPTICAL SIGHTING AND RANGI… ## $ quantity &lt;dbl&gt; 10, 1, 10, 9, 10, 1, 1, 1, 1, 1, 1, 1, 3, 12, 1, 5, … ## $ ui &lt;chr&gt; &quot;Kit&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each&quot;, &quot;Each… ## $ acquisition_value &lt;dbl&gt; 15871.59, 245.88, 1626.00, 333.00, 926.00, 658000.00… ## $ ship_date &lt;dttm&gt; 2018-01-30, 2016-06-02, 2016-09-19, 2016-09-14, 201… ## $ station_type &lt;chr&gt; &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;, &quot;State&quot;… ## $ total_value &lt;dbl&gt; 158715.90, 245.88, 16260.00, 2997.00, 9260.00, 65800… 8.4 Wrangle the data To prepare the data for visualizing, we need to do a couple more new things. This is going to take several steps, which we will pipe together. filter the data to focus on more recent data. Let’s specifically consider military surplus in 2010 and after. And then, create a month variable using the floor_date() function. floor_date() is a function in lubridate that allows us to aggregate And then, select a few variables to study (specifically, month, total_value, state, and agency_name) In this chunk of code, we’ll use a new function we haven’t learned about before: floor_date(). This is the date-equivalent of rounding: we use floor_date() to “round down” a date, so “2022-01-25” (January 25, 2022) becomes “2022-01-01.” This can be useful when we want to aggregate information from the day-level to the week, month, or year level. floor_date() takes two arguments: the date-time object (in our case, the date variable in the tx data frame) and the unit that you want to round to (in our case, \"month\", but you can also do week, bi-month, quarter, year, and so on). leso_total &lt;- leso_total %&gt;% filter(ship_date &gt;= as.Date(&quot;2010-01-01&quot;)) %&gt;% mutate(month = floor_date(ship_date, &quot;month&quot;)) %&gt;% select(month, total_value, state) glimpse(leso_total) ## Rows: 84,605 ## Columns: 3 ## $ month &lt;dttm&gt; 2018-01-01, 2016-06-01, 2016-09-01, 2016-09-01, 2017-03-0… ## $ total_value &lt;dbl&gt; 158715.90, 245.88, 16260.00, 2997.00, 9260.00, 658000.00, … ## $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;… There’s a lot of information in this data, so let’s focus our data visualizing on Texas, like we did in our previous chapters. We’ll do this by filtering the rows where state == \"TX\". leso_texas &lt;- leso_total %&gt;% filter(state == &quot;TX&quot;) Now that we have our data in a nice structure, with some monthly information, let’s use our GSA process (group_by() %&gt;% summarize() %&gt;% arrange()). In this process, we’ll group by month (the variable we have just created), summarize a the total value of the military surplus (by month) and arrange that information chronologically. leso_texas_gsa &lt;- leso_texas %&gt;% group_by(month) %&gt;% summarize(monthly_cost = sum(total_value)) %&gt;% arrange(month) head(leso_texas_gsa) #use head() to view the first 6 rows of this new data frame ## # A tibble: 6 × 2 ## month monthly_cost ## &lt;dttm&gt; &lt;dbl&gt; ## 1 2010-01-01 00:00:00 92290 ## 2 2010-02-01 00:00:00 5447 ## 3 2010-03-01 00:00:00 5399589. ## 4 2010-04-01 00:00:00 267113. ## 5 2010-05-01 00:00:00 181700. ## 6 2010-06-01 00:00:00 16983 We may come back to the data to fix some stuff but for now, we’re ready to plot! If any of these steps are confusing to you, we encourage you to go back to Chapter 5 and 6. 8.5 Make a line chart of the Texas data Data visualization is an iterative process: you may prepare the data, do the visualization, and then realize you want to prepare the data a different way. Remember that the process of coding can involve trial and error: you’re often testing different thing to see what works. 8.5.1 Plot the chart Alright, so now let’s get ready to use the ggplot() function. I want you to create the plot here one step at a time so you can review how the layers are added. In this new plot, we’ll learn about a new geom layer: geom_line() (recall that in Chapter 7, we learned about geom_point() and geom_col()). Add and run the ggplot() line first (but without the +) Then add the + and the geom_point() and run it. Then add the + and geom_line() and run it. Then add the + and labs(), and run everything. ggplot(leso_texas_gsa, aes(x = month, y = monthly_cost)) + #we create the graph geom_point() + #adding the points geom_line() + #adding the lines between the points labs(title = &quot;Law Enforcement Support Office Data, Texas&quot;, x = &quot;Months&quot;, y = &quot;Cost of acquisitions&quot;) 8.5.2 Cleaning Up Alright, so we have a working plot! But there’s a couple things that are a bit ugly about this plot. First, I’m not digging the weird numbers on the side (what the heck does 0.0e+00 even mean?!). To fix this, let’s go back to our data and do a bit more preparing. If we use head() to look at our data, we’ll notice that there are a few numbers that are just really, really big. head(leso_texas_gsa) #use head() to view the first 6 rows of this new data frame ## # A tibble: 6 × 2 ## month monthly_cost ## &lt;dttm&gt; &lt;dbl&gt; ## 1 2010-01-01 00:00:00 92290 ## 2 2010-02-01 00:00:00 5447 ## 3 2010-03-01 00:00:00 5399589. ## 4 2010-04-01 00:00:00 267113. ## 5 2010-05-01 00:00:00 181700. ## 6 2010-06-01 00:00:00 16983 These large numbers are causing R to read our numbers as “scientific notation” (a math-y way of reading large numbers). For example, the total cost of supplies in February 2010 was 5,399,589.0 (that’s the first spike in our figure, around the 5.0e + 06 mark). But what a pain to read! To get around this, let’s divide our monthly_cost variable (in the leso_tx_gsa data frame) by 1 million. Just like we round our numbers when we write about data, so too do we often round numbers when we visualize it. In the line below, we use mutate() to divide monthly_cost by 1,000,000. leso_texas_gsa &lt;- leso_texas_gsa %&gt;% mutate(monthly_cost = monthly_cost/1000000) #divide by 1 million head(leso_texas_gsa) ## # A tibble: 6 × 2 ## month monthly_cost ## &lt;dttm&gt; &lt;dbl&gt; ## 1 2010-01-01 00:00:00 0.0923 ## 2 2010-02-01 00:00:00 0.00545 ## 3 2010-03-01 00:00:00 5.40 ## 4 2010-04-01 00:00:00 0.267 ## 5 2010-05-01 00:00:00 0.182 ## 6 2010-06-01 00:00:00 0.0170 Now, let’s re-visualize our data. Notice that in the labs layer below, we add some new information to the y-axis, so people know that the 5 here refers to 5 million. ggplot(leso_texas_gsa, aes(x = month, y = monthly_cost)) + #we create the graph geom_point() + #adding the points geom_line() + #adding the lines between the points labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas&quot;, x = &quot;Months&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) Our chart is looking much better! 8.5.3 Saving plots as an object Sometimes it is helpful to push the results of a plot into an R object to “save” those configurations. You can continue to add layers to this object, but you won’t need to rebuild the main portions of the chart each time. We’ll do that here so we can explore themes next. Edit your Texas plot chunk you made earlier to save it into an R object, and then call tx_plot after it so you can see it. # the line below saves the graph results into tx_plot tx_plot &lt;- ggplot(leso_texas_gsa, aes(x = month, y = monthly_cost)) + geom_point() + geom_line() + labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas&quot;, x = &quot;Months&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) # Since we saved the plot into an R object above, we have to call it again to see it. # We save graphs like this so we can reuse them. tx_plot We can continue to build upon the tx_plot object like we do below with themes, but those changes won’t be “saved” into the R environment unless you assign it to an R object. 8.6 Themes The look of the graph is controlled by the theme. There are a number of preset themes you can use. Let’s look at a couple. Create a new section saying we’ll explore themes. Add the chunk below and run it. tx_plot + theme_minimal() This takes our existing tx_plot and then applies the theme_minimal() look to it. There are a number of themes built into ggplot, most are pretty simplistic. Edit your existing chunk to try different themes. Some you might try are theme_classic(), theme_dark() and theme_void(). 8.6.1 More with ggthemes There are a number of other packages that build upon ggplot2, including ggthemes. In your R console, install the ggthemes package: install.packages(\"ggthemes\") Add the library(ggthemes) at the top of your current chunk. Update the theme line to view some of the others options noted below. library(ggthemes) tx_plot + theme_economist() tx_plot + theme_fivethirtyeight() tx_plot + theme_stata() 8.6.2 There is more to themes There is also a theme() function that allows you individually adjust about every visual element on your plot. We do a wee bit of that later. 8.7 Adding more information OK, our Texas higher education spending is fine … but how does that compare to neighboring states? Let’s work through building a new chart that shows all those steps. 8.7.1 Prepare the data We need to go back to our original leso_total to get the additional states. Start a new section that notes we are building a chart for five states (Texas, Oklahoma, Arkansas, New Mexico, and Louisiana) Prepare the data using the %in% filter that we learned about in Chapter 6. Rather than creating a separate list, we’re going to write the list right into the filter() function using c(). leso_five &lt;- leso_total %&gt;% filter( state %in% c(&quot;TX&quot;, &quot;OK&quot;, &quot;AR&quot;, &quot;NM&quot;, &quot;LA&quot;) ) leso_five ## # A tibble: 11,546 × 3 ## month total_value state ## &lt;dttm&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2021-12-01 00:00:00 421. AR ## 2 2021-11-01 00:00:00 44478 AR ## 3 2021-12-01 00:00:00 4977. AR ## 4 2021-11-01 00:00:00 168 AR ## 5 2021-12-01 00:00:00 232. AR ## 6 2018-08-01 00:00:00 1918 AR ## 7 2021-12-01 00:00:00 0 AR ## 8 2015-04-01 00:00:00 3861 AR ## 9 2013-05-01 00:00:00 89900 AR ## 10 2014-09-01 00:00:00 89900 AR ## # … with 11,536 more rows Now that we have our five states, let’s GSA this information, like we did earlier (but for all 5 states and not just Texas). Again, this should be a refresher! leso_five_gsa &lt;- leso_five %&gt;% group_by(state, month) %&gt;% #groups by state AND month summarize(monthly_cost = sum(total_value)) %&gt;% mutate(monthly_cost = monthly_cost/1000000) #divide by 1 million ## `summarise()` has grouped output by &#39;state&#39;. You can override using the `.groups` argument. leso_five_gsa %&gt;% glimpse() ## Rows: 452 ## Columns: 3 ## Groups: state [5] ## $ state &lt;chr&gt; &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR&quot;, &quot;AR… ## $ month &lt;dttm&gt; 2010-12-01, 2011-01-01, 2011-03-01, 2011-04-01, 2011-05-… ## $ monthly_cost &lt;dbl&gt; 0.00207600, 0.05097442, 0.00301800, 0.05546326, 0.0571645… 8.7.2 Plot multiple line chart For our next plot, we’ll add a different line for each state. To do this you would use the color aesthetic aes() in the geom_line() geom. Recall that geoms can have their own aes() variable information. This is especially useful for working with a third variable (like when making a stacked bar chart or line plot with multiple lines). Notice that the color aesthetic (meaning that it is in aes) takes a variable, not a color. You can learn how to change these colors here. For now, though, we’ll use the ggplot default colors. Add a note that we’ll now build the chart. Add the code chunk below and run it. Look through the comments so you understand it. ggplot(leso_five_gsa, aes(x = month, y = monthly_cost)) + geom_point() + geom_line(aes(color = state)) + # The aes selects a color for each state labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas and Boardering States&quot;, x = &quot;Month&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) Notice that R changes the color of the line, but not the point? This is because we only included the aesthetic in the geom_line() geom and not the geom_point() geom. Edit your geom_point() to add aes(color = state). ggplot(leso_five_gsa, aes(x = month, y = monthly_cost)) + geom_point(aes(color = state)) + geom_line(aes(color = state)) + # The aes selects a color for each state labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas and Boardering States&quot;, x = &quot;Month&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) 8.8 On your own: Line chart I want you to make a line chart of military surplus acquisitions in three states that are different from the five we used above. This is very similar to the chart you just made, but with different values. Some things to do/consider: Do this in a new section and explain it. You’ll need to prepare the data just like we did above to get the right data points and the right states. I really suggest you build both chunks (the data prep and the chart) one line at a time so you can see what each step adds. 8.9 Tour of some other adjustments You don’t have to add these examples below to your own notebook, but here are some examples of other things you can control. 8.9.1 Line width ggplot(leso_five_gsa, aes(x = month, y = monthly_cost)) + geom_point(aes(color = state)) + geom_line(aes(color = state), size = 1.5) + #make the lines thicker here labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas and Boardering States&quot;, x = &quot;Month&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) 8.9.2 Line type This example removes the points and adds a linetype = state to the ggplot aesthetic. This gives each state a different type of line. We also set the color in the geom_line() ggplot(leso_five_gsa, aes(x = month, y = monthly_cost)) + geom_point(aes(color = state)) + geom_line(aes(color = state, linetype = state), size = 0.75) + #changes the line type labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas and Boardering States&quot;, x = &quot;Month&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) Notice that when you put the information geom_line(aes()) (like with color and linetype), this varies the color and linetype of the lines, whereas size is consistent for all the lines. 8.9.3 Adjust axis ggplot() typically makes assumptions about scale. Sometimes, you may want to change it though (e.g., make them a little larger). There are a couple different ways to do this. The most straightforward may be xlim() and ylim(). ggplot(leso_five_gsa, aes(x = month, y = monthly_cost)) + geom_point(aes(color = state)) + geom_line(aes(color = state, linetype = state), size = 0.75) + #changes the line type xlim(as.POSIXct(&quot;2009-07-01&quot;), as.POSIXct(&quot;2022-02-01&quot;)) + # sets minimum and maximum values on axis labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas and Boardering States&quot;, x = &quot;Month&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) The function xlim() and ylim() are shortcuts for scale_x_continuous() and scale_y_continuous() which do more things. 8.10 Facets Facets are a way to make multiple graphs based on a variable in the data. There are two types, the facet_wrap() and the facet_grid(). There is a good explanation of these in R for Data Science. We’ll start by creating a base graph and then apply the facet. Start a new section about facets Add the code below to create your chart and view it. This is the same plot we’ve already created five_plot &lt;- ggplot(leso_five_gsa, aes(x = month, y = monthly_cost)) + geom_point(aes(color = state)) + geom_line(aes(color = state)) + labs(title = &quot;Monthly Value of Military Surplus Acquisitions in Texas and Boardering States&quot;, x = &quot;Month&quot;, y = &quot;Cost of acquisitions (in millions)&quot;, caption = &quot;Source: Law Enforcement Support Office&quot;) five_plot 8.10.1 Facet wrap The facet_wrap() splits your chart based on a single variable. You define which variable to split upon with ~ followed by the variable name. Add a new chunk and create the facet wrap shown here. five_plot + facet_wrap(~ state) + theme(legend.position = &quot;none&quot;) # removes the legend. Try it without it! A couple of notes about the above code: Note the comment in the code above where we used the theme() function to remove the legend. You can specify the number of rows or columns of the grouping by adjusting the facet_wrap() function: facet_wrap(~ state, nrow = 2) or facet_wrap(~ state, ncol = 2). Try them! 8.10.2 Facet grids A facet_grid() allows you to plot on a combination of variables. We don’t really have two numbers to compare in our higher education data so we’ll show this with the mpg data we’ve used before. Start a new section noting you’ll try facet grid. Add the chunk below and run it. Explanations follow the chart. ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) + # add points to the chart facet_grid(drv ~ cyl) # splits into charts by drive train and cylinder This chart is kinda hard to read, but let’s try: Inside the mini charts, the best gas mileage is toward the top (from hwy) and the smaller engines are to the left (from displ.) The rows of charts are divided by drive train drv: four-wheel drive, front-wheel drive and rear-wheel drive. The columns of charts are divided by cylinders: like a 4-cylinder car vs 8-cylinder car. This chart tells us that 4-cylinder, front-wheel drive cars with smaller engines get the best gas mileage. The blank charts mean that combination of values didn’t exist in the data. 8.11 On your own: Facet wrap Create a section about doing a facet wrap on your own. Take the “On your own” plot that you made earlier (The other states that you chose) and apply a facet_wrap() here. You were instructed to save the plot into an R object, so you should be able to use that. Remove the legend since each mini chart is labeled. 8.12 Saving plots To save plots as images, you can right-click plots that you make in RNotebooks. Or, you can use the export button in the Plot pane. Or (and this is a preferred strategy), you can save them using ggsave(). (Learn more here). Use your Files pane to create a new folder called “images” so we can save our chart there. Start a section on saving plots and add the following chunk. ggsave(&quot;images/txplot.png&quot;, plot = tx_plot) ## Saving 7 x 5 in image Using ggsave creates a higher-res image than other methods. It needs: The path and name of the image, in quotes the plot = variable to say which plot you are saving. (Your plot must already be saved into an R object for this method to work.) 8.13 Interactive plots Want to make your plot interactive? You can use plotly’s ggplotly() function to transform your graph into an interactive chart. To use plotly, you’ll want to install the plotly package, add the library, and then use the ggplotly() function: In your R Console, run install.packages(\"plotly\"). (You only have to do this once on your computer.) Add a new section to note you are creating an interactive chart. Add the code below and run it. Then play with the chart! library(plotly) tx_plot %&gt;% ggplotly() (We can’t show the interactive version in this book.) Now you have tool tips on your points when you hover over them. The ggplotly() function is not perfect. Alternatively, you can use plotly’s own syntax to build some quite interesting charts, but it’s a whole new syntax to master. 8.14 What we learned There is so much more to ggplot2 than what we’ve shown here, but these are the basics that should get you through the class. At the top of this chapter are a list of other resources to learn more. "],["tidy-data.html", "Chapter 9 Tidy data 9.1 Goals for this section 9.2 The questions we’ll answer 9.3 What is tidy data 9.4 Wide vs long data 9.5 The tidyr verbs 9.6 Prepare our candy project 9.7 Drop unneeded columns 9.8 Pivot longer 9.9 Get average candies per color 9.10 Introducing Datawrapper 9.11 Pivot wider 9.12 Bonus questions 9.13 Turn in your work 9.14 What we learned", " Chapter 9 Tidy data Data “shape” can be important when you are trying to work with and visualize data. In this chapter we’ll discuss “tidy data” and how it helps us with both ggplot and other charting tools like Datawrapper. This chapter was written by Prof. McDonald, who uses a Mac. 9.1 Goals for this section Explore what it means to have “tidy” data. Learn about and use pivot_longer(), pivot_wider() to make our data tidy. Use candy data to practice shaping data. 9.2 The questions we’ll answer Are candy colors evenly distributed within a standard package of M&amp;M’s? (We’ll get the mean of candies by color over a collection of packages.) We’ll plot the result as a column chart to show the average number of colored candies. We’ll do it first in ggplot, then Datawrapper. Bonus 1: Who got the most candies in their bag? Bonus 2: What is the average number of candy in a bag? 9.3 What is tidy data “Tidy” data is well formatted so each variable is in a column, each observation is in a row and each value is a cell. Our first step in working with any data is to make sure we are “tidy.” Tidy data definition It’s easiest to see the difference through examples. The data frame below is of tuberculosis reports from the World Health Organization. Each row is a set of observations (or case) from a single country for a single year. Each column describes a unique variable. The year, the number of cases and the population of the country at that time. A tidy table Table2 below isn’t tidy. The count column contains two different type of values. An untidy table When our data is tidy, it is easy to manipulate. We can use functions like mutate() to calculate new values for each case. Manipulate a tidy table When our data is tidy, we can use the tidyr package to reshape the layout of our data to suit our needs. It gets loaded with library(tidyverse) so we won’t need to load it separately. 9.4 Wide vs long data In the figure below, the table on the left is “wide.” There are are multiple year columns describing the same variable. It might be useful if we want to calculate the difference of the values for two different years. It’s less useful if we want plot on a graphic because we don’t have a single “year” column to map as an x or y axes. The table on the right is “long,” in that each column describes a single variable. It is this shape we need when we want to plot values on a chart in ggplot. We can then set our “Year” column as an x-axis, our “n” column on our y-axis, and group by the “Country.” Wide vs long Neither shape is wrong, they are just useful for different purposes. In fact, you’ll find yourself pivoting the same data in different ways depending on your needs. 9.5 The tidyr verbs The two functions we’ll use to reshape are data are: pivot_longer() which “lengthens” data, increasing the number of rows and decreasing the number of columns. pivot_wider() which “widens” data, increasing the number of columns and decreasing the number of rows. Again, the best way to learn this is to present a problem and then solve it with explanation. 9.6 Prepare our candy project We will use candy count data we’ve been collected in Reporting wth Data classes to explore this subject. Start a new project. Create a new project and call it: yourname-candy No need to create data folders as we’ll just load data directly into the notebook. Start a new R Notebook and edit the headline. Name it 01-candy. Create your setup block and load the libraries below. library(tidyverse) library(janitor) 9.6.1 Get the data We’ll just load this data directly from Google Sheets into this notebook. We’re doing something a little different here in we save the URL to our data into an object, then use that object in our read_csv() function. This is just a convenience for me, really, so I can swap that url out as needed. Add a Markdown section noting that you are importing data. Add this import chunk and run it. # save the url class_data &lt;- &quot;https://docs.google.com/spreadsheets/d/e/2PACX-1vRCGayKLOy-52gKmEoPOj3ZKnOQVtCiooSloiCr-i_ci27e4n1CMPL0Z9s6MeFX9oQuN9E-HCFJnWjD/pub?gid=1456715839&amp;single=true&amp;output=csv&quot; # read the data, clean names and save into the object &quot;raw_data&quot; raw_data &lt;- read_csv(test_data) %&gt;% clean_names() # peek at the data raw_data ## # A tibble: 31 × 10 ## timestamp first_name last_name candy_type red green orange yellow blue ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2/21/2022 19… Christian McDonald Plain 2 17 11 4 16 ## 2 2/21/2022 19… First1 Last1 Plain 15 1 17 5 20 ## 3 2/21/2022 19… First2 Last2 Plain 14 15 4 13 12 ## 4 2/21/2022 19… First3 Last3 Plain 7 1 7 4 6 ## 5 2/21/2022 19… First4 Last4 Plain 6 2 8 6 13 ## 6 2/21/2022 19… First5 Last5 Plain 13 7 20 5 7 ## 7 2/21/2022 19… First6 Last6 Plain 14 2 3 8 2 ## 8 2/21/2022 19… First7 Last7 Plain 20 15 17 19 1 ## 9 2/21/2022 19… First8 Last8 Plain 8 13 14 10 12 ## 10 2/21/2022 19… First9 Last9 Plain 20 8 4 18 14 ## # … with 21 more rows, and 1 more variable: brown &lt;dbl&gt; This data comes from a Google Sheets document fed by a form that students have filled out, counting the colors of candies in a standard size bag of plain M&amp;Ms. 9.7 Drop unneeded columns For this exercise we don’t need the timestamp and candy_type columns. We’ll drop them so we can keep things simple. Create a Markdown section noting you’ll drop unneeded columns. Create an R chunk and use select() to remove the columns noted above and save the result into a new data frame called candy. You’ve done this in the past, so you should be able to do it on your own. You got this! (But, just in case …) candy &lt;- raw_data %&gt;% select( -timestamp, -candy_type ) 9.7.1 Peek at the wide table Let’s look closer at this data: candy %&gt;% head() ## # A tibble: 6 × 8 ## first_name last_name red green orange yellow blue brown ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Christian McDonald 2 17 11 4 16 4 ## 2 First1 Last1 15 1 17 5 20 8 ## 3 First2 Last2 14 15 4 13 12 5 ## 4 First3 Last3 7 1 7 4 6 9 ## 5 First4 Last4 6 2 8 6 13 16 ## 6 First5 Last5 13 7 20 5 7 13 This is pretty well-formed data. This format would be useful to create a “total” column for each bag, but there are better ways to do this with long data. Same with getting our averages for each color. 9.8 Pivot longer This visualization gives you an idea how pivot_longer() works. Pivot longer Each column of data chosen (the colored ones) is turned into it’s own row of data. Supporting data (the grey columns) are duplicated. The pivot_longer() function needs several arguments: cols=, names_to= and values_to. Below are two examples to pivot the example data shown above. pivot_longer code cols= is where you define a range of columns you want to pivot. For our candy data we want the range red:brown. names_to= allows you to name the new column filled by the column names. For our candy data we want to name this “color” since that’s what those columns described. `values_to= allows you to name the new column filled with the cell data. For us we want to call this “candies” since these are the number of candies in each bag. There are a number of ways we can describe the cols= argument … anything in tidy-select works. You can see a bunch of examples here. 9.8.1 Pivot our candy data longer What we want here is five rows for each person’s entry, with a column for “color” and a column for “candies.” We are using a range, naming the first “red” and the last column “brown” with : in between. This only works because those columns are all together. We could also use cols = !c(first_name, last_name) to say everything but those two columns. Add a note that you are pivoting the data Add the chunk below and run it candy_long &lt;- candy %&gt;% pivot_longer( cols = red:brown, # sets which columns to pivot based on their names names_to = &quot;color&quot;, # sets column name for color values_to = &quot;candies&quot; # sets column name for candies ) candy_long %&gt;% head(10) ## # A tibble: 10 × 4 ## first_name last_name color candies ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Christian McDonald red 2 ## 2 Christian McDonald green 17 ## 3 Christian McDonald orange 11 ## 4 Christian McDonald yellow 4 ## 5 Christian McDonald blue 16 ## 6 Christian McDonald brown 4 ## 7 First1 Last1 red 15 ## 8 First1 Last1 green 1 ## 9 First1 Last1 orange 17 ## 10 First1 Last1 yellow 5 9.9 Get average candies per color To get the average number of candies per each color, we can use our candy_long data and group_by color (which will consider all the red rows together, etc.) and use summarize() to get the mean. This is something you should be able to do on your own, as it is very similar to the sum()s we did with military surplus, but you use mean() instead. Save the resulting summary table into a new tibble called candy_avg. Try it on your own candy_avg &lt;- candy_long %&gt;% group_by(color) %&gt;% summarize(avg_candies = mean(candies)) candy_avg ## # A tibble: 6 × 2 ## color avg_candies ## &lt;chr&gt; &lt;dbl&gt; ## 1 blue 10.7 ## 2 brown 10.9 ## 3 green 11.3 ## 4 orange 10.5 ## 5 red 10.2 ## 6 yellow 10.4 9.9.1 Round the averages Let’s modify this summary to round the averages to tenths so they will plot nicely on our chart.’ The round() function needs the column to change, and then the number of digits past the decimal to include. Edit your summary to include the mutate below. candy_avg &lt;- candy_long %&gt;% group_by(color) %&gt;% summarize(avg_candies = mean(candies)) %&gt;% mutate( avg_candies = round(avg_candies, 1) ) candy_avg ## # A tibble: 6 × 2 ## color avg_candies ## &lt;chr&gt; &lt;dbl&gt; ## 1 blue 10.7 ## 2 brown 10.9 ## 3 green 11.3 ## 4 orange 10.5 ## 5 red 10.2 ## 6 yellow 10.4 BONUS POINT OPPORTUNITY: Using a similar method to rounding above, you can also capitalize the names of the colors. You don’t have to do this, but I’ll give you bonus points if you do: In your mutate, add a rule that updates color column using str_to_title(color). You can read more about converting the case of a string here. It’s part of the stringr package, which is loaded with tidyverse. 9.9.2 On your own: Plot the averages Now I want you to use ggplot to create a bar chart that shows the average number of candies in a bag. This is very similar to your plots of Disney Princesses and ice cream in Chapter 6. Build a bar chart of averge color using ggplot. Some things to consider: I want the bars to be ordered by the highest average on top. I want a good title, subtitle and byline, along with good axes names. Include the values on the bars Change the theme to something other than the default Here is what it should look like, but with good text, etc: The numbers above may not be up to date, so don’t let that throw you. 9.10 Introducing Datawrapper There are some other great charting tools that journalists use. My favorite is Datawrapper and is free for the level you need it. Datawrapper is so easy I don’t even have to teach you how to use it. They have excellent tutorials. What you do need is the data to plot, but you’ve already “shaped” it the way you need it. Your candy_avg tibble is what you need. Here are the steps I want you to follow: 9.10.1 Review how to make a bar chart In a web browser, go to the Datawrapper Academy Click on Bar charts Choose How to create a bar chart The first thing to note there is they show you what they expect the data to look like. Your candy_avg tibble is just like this, but with Color and Candies. You’ll use these directions to create your charts so you might keep this open in its own tab. 9.10.2 Start a chart In a new browser tab, go to datawrapper.de and click the big Start creating button. Use the Login/Sign Up button along the top to create an account or log in if you have one. The first screen you have is where you can Upload data or paste it into the window. We are going to paste the data, but we have to do some stuff in R to get it. 9.10.3 Get your candies data We need to install a package called clipr. In your R project in the R Console install the package clipr: install.packages(\"clipr\"). Start a section that says you are going to get data for Datawrapper. Create a chunk with the following and run it. library(clipr) candy_avg %&gt;% write_clip(allow_non_interactive = TRUE) You won’t see anything happen, but all the data in candy_avg has been added to your clipboard as if you highlighted it and did Copy. You must have the allow_non_interactive = TRUE argument to allow your RMarkdown document to knit. 9.10.4 Build the datawrapper graphic Return to your browser where you are making the chart, put your cursor into the “Paste your copied data here …” window and paste. (Like Cmd-V or use the menu Edit &gt; Paste.) Click Proceed. You can now follow the Datawrapper Academy directions to finish your chart. When you get to the Publish &amp; Embed window, I want you to click the Publish Now button and then add the resulting Link to your visualization: URL to your R Notebook so I can find it for grading. 9.11 Pivot wider In this case we don’t have a real need to pivot our data wider, but I’d like to show you how it is done. As you can imagine, pivot_wider() does the opposite of pivot_longer(). When we pivot wider we move our data from a “long” format to a “wide” format. We create a new column based categories and values in the data. Long to wide We’ll practice this by taking our long candy data and pivot it so there is a column for each person in the data. pivot_wider() needs two arguments: names_from = lets us define from which column (or columns) we are pulling values from to create the new column names. In our case, we need two columns to combine the first and last names. We can do that with c(first_name, last_name). values_from = lets us say which column will be the values in the new arrangement. In our case, we want the candies column. candy_long %&gt;% pivot_wider(names_from = c(first_name, last_name), values_from = candies) ## # A tibble: 6 × 32 ## color Christian_McDonald First1_Last1 First2_Last2 First3_Last3 First4_Last4 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 red 2 15 14 7 6 ## 2 green 17 1 15 1 2 ## 3 orange 11 17 4 7 8 ## 4 yellow 4 5 13 4 6 ## 5 blue 16 20 12 6 13 ## 6 brown 4 8 5 9 16 ## # … with 26 more variables: First5_Last5 &lt;dbl&gt;, First6_Last6 &lt;dbl&gt;, ## # First7_Last7 &lt;dbl&gt;, First8_Last8 &lt;dbl&gt;, First9_Last9 &lt;dbl&gt;, ## # First10_Last10 &lt;dbl&gt;, First11_Last11 &lt;dbl&gt;, First12_Last12 &lt;dbl&gt;, ## # First13_Last13 &lt;dbl&gt;, First14_Last14 &lt;dbl&gt;, First15_Last15 &lt;dbl&gt;, ## # First16_Last16 &lt;dbl&gt;, First17_Last17 &lt;dbl&gt;, First18_Last18 &lt;dbl&gt;, ## # First19_Last19 &lt;dbl&gt;, First20_Last20 &lt;dbl&gt;, First21_Last21 &lt;dbl&gt;, ## # First22_Last22 &lt;dbl&gt;, First23_Last23 &lt;dbl&gt;, First24_Last24 &lt;dbl&gt;, … 9.12 Bonus questions More opportunities for bonus points on this assignment. These aren’t plots, just data wrangling to find answers. 9.12.1 Most/least candies Answer me this: Who got the most candies in their bag? Who got the least? I want a well-structured section (headline, text) with two chunks, one for the most and one for the least. 9.12.2 Average total candies in a bag Answer me this: What is the average number of candy in a bag? Again, well-structured section and include the code. Hint: You need a total number of candies per person before you can get an average. 9.13 Turn in your work Make sure your notebook runs start-to-finish. Knit the notebook Stuff your project and turn it into the Candy assignment in Canvas. 9.14 What we learned We learned what “tidy data” means and why it is important. It is the best shape for data wrangling and plotting. We learned about pivot_longer() and pivot_wider() and we used pivot_longer() on our candy data. We also used round() to round off some numbers, and you might have used str_to_title() to change the case of the color values. "],["plot-aac.html", "Chapter 10 Plotting for answers 10.1 Goals of this lesson 10.2 Questions we will answer 10.3 Create your project 10.4 Download the data 10.5 Import your data 10.6 Fix the dates 10.7 Parse the date into helpful variables 10.8 On your own: Filter dates 10.9 On your own: Export your data 10.10 Set up your analysis notebook 10.11 On your own: Import your cleaned data 10.12 Question 1: Intakes by year 10.13 Question 2: Intakes by month 10.14 Question 3: Intakes by month, split by year 10.15 Question 4: Animal types by month 10.16 What we learned 10.17 Turn in your work 10.18 What’s next", " Chapter 10 Plotting for answers For this chapter, we will use some data from the City of Austin data portal on animal intakes to the Austin Animal Center. You’ll use that portal to download the data, prepare it for R, then answer some questions and make plots to show the answers. Along the way we’ll learn some stuff. 10.1 Goals of this lesson We’ll use some string and date function to clean and parse some dates. We’ll use count() to make some summaries. All of our “answers” are counting operations, so we’ll practice using that shortcut instead of “GSA.” We’ll learn how to add commas to axis names in ggplot with the scales package. We’ll use recode() to update some values in our data. 10.2 Questions we will answer We’ll tackle these after we clean our data, but so you know where we are going: Are animal intakes increasing or decreasing each year since 2016? Plot a column chart of intakes by year. Don’t include 2021 since it is not a full year. Are there seasonal monthly trends in overall animal intakes? Plot intakes by year/month from 2016 to current, including 2021. (One long line or column chart.) Plot that same monthly trend, except with month as the x axis, with a new line for each year. Do certain types of animals drive seasonal trends? Use five full years of data (not 2021) to summarize intakes by animal type and month. Plot with month on the x axis with a line for each animal type. 10.3 Create your project We’ll be starting a new R project with our typical folder structure. Create a new project. Call it yourname-aac. Create your data-raw and data-processed folders. Create a new R Notebook, title it “AAC Import/clean” and name the file 01-import.Rmd Add your setup section with the following libraries: library(tidyverse) library(janitor) library(lubridate) As always, create good Markdown sections, descriptions, add notes and name your R chunks so you have good bookmarks to work with. 10.4 Download the data This time you have to go get your data online and then put the file into your data-raw folder yourself. Go to https://data.austintexas.gov/ Search for “animal intakes.” Find the link “Austin Animal Center Intakes” and click on it. (It may not be the first return, so be careful to get the right one.) This page tells you about the data at the top. Note that records go back to October 2013. Further down the page there is a list of the “Columns in this Dataset” that kinda describes them, and you can see an example of the data at the bottom. Review those. At the top-right of the page is an Export button. Click on that and choose CSV. This will save the file called Austin_Animal_Center_Intakes.csv to your computer’s Downloads folder. Find your Downloads folder and the file on your computer, and them move the csv file into your data-raw folder in your project folder. Note that when you source this data in stories or charts, it comes from the Austin Animal Center, not the city’s data portal. The portal is just the delivery method. 10.5 Import your data Go back into RStudio in your 01-import.Rmd file and import the data. You’ve done this many times now and should be able to do it on your own. Don’t forget to create a section with a headline, etc. Work one line at a time. Use read_csv() to find your data and load it onto the screen. Once that is using, add a %&gt;% and use the clean_names() function to fix the column names. Once that is all good, edit the chunk to save the imported data into a new tibble called raw_data. You shouldn’t need this. raw_data &lt;- read_csv(&quot;data-raw/Austin_Animal_Center_Intakes.csv&quot;) %&gt;% clean_names() # peek at the data raw_data ## # A tibble: 132,214 × 12 ## animal_id name date_time month_year found_location intake_type ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A786884 *Brock 01/03/2019 … 01/03/2019 0… 2501 Magin Meadow D… Stray ## 2 A706918 Belle 07/05/2015 … 07/05/2015 1… 9409 Bluegrass Dr i… Stray ## 3 A724273 Runster 04/14/2016 … 04/14/2016 0… 2818 Palomino Trail… Stray ## 4 A665644 &lt;NA&gt; 10/21/2013 … 10/21/2013 0… Austin (TX) Stray ## 5 A682524 Rio 06/29/2014 … 06/29/2014 1… 800 Grove Blvd in A… Stray ## 6 A743852 Odin 02/18/2017 … 02/18/2017 1… Austin (TX) Owner Surr… ## 7 A635072 Beowulf 04/16/2019 … 04/16/2019 0… 415 East Mary Stree… Public Ass… ## 8 A708452 Mumble 07/30/2015 … 07/30/2015 0… Austin (TX) Public Ass… ## 9 A818975 &lt;NA&gt; 06/18/2020 … 06/18/2020 0… Braker Lane And Met… Stray ## 10 A774147 &lt;NA&gt; 06/11/2018 … 06/11/2018 0… 6600 Elm Creek in A… Stray ## # … with 132,204 more rows, and 6 more variables: intake_condition &lt;chr&gt;, ## # animal_type &lt;chr&gt;, sex_upon_intake &lt;chr&gt;, age_upon_intake &lt;chr&gt;, ## # breed &lt;chr&gt;, color &lt;chr&gt; 10.6 Fix the dates Take a look at the date_time and month_year columns. They are both timestamps that include both the date and time. They imported as a character datatype &lt;chr&gt; and are in this format: 01/03/2019 04:19:00 PM We won’t be using the time for this exercise, so all we really need is the date. Lubridate doesn’t have a conversion for this exact format (at least that I could find.) That’s ok, we’ll use some stringr functions to whip this into shape. We can use a function called str_sub() to pluck out the date from this string. We’ll create a new column using mutate() to do this. You’ve used mutate before. str_sub() allows you to pluck any number of characters out of a string. We want the first 10 characters: “01/03/2019.” It takes three arguments: The column you are looking at? For us, this is the date_time column. What position do you want to start at? For us, we start at “1,” the first character. How many characters do you want? For us, we want “10.” We use this inside a mutate() function to create a new column with the results of the str_sub() function. Create a new section and note we are fixing the date. Create a chunk, call your raw_data and pipe that into a mutate() function. Inside your mutate, name your new column intake_date. Set intake_date to = to str_sub(date_time, 1, 10). Try it, and then check the last column of the data that comes back to make sure you actually have a 10-character string like “01/03/2019.” Part of the answer raw_data %&gt;% mutate( intake_date = str_sub(date_time, 1, 10) ) ## # A tibble: 132,214 × 13 ## animal_id name date_time month_year found_location intake_type ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A786884 *Brock 01/03/2019 … 01/03/2019 0… 2501 Magin Meadow D… Stray ## 2 A706918 Belle 07/05/2015 … 07/05/2015 1… 9409 Bluegrass Dr i… Stray ## 3 A724273 Runster 04/14/2016 … 04/14/2016 0… 2818 Palomino Trail… Stray ## 4 A665644 &lt;NA&gt; 10/21/2013 … 10/21/2013 0… Austin (TX) Stray ## 5 A682524 Rio 06/29/2014 … 06/29/2014 1… 800 Grove Blvd in A… Stray ## 6 A743852 Odin 02/18/2017 … 02/18/2017 1… Austin (TX) Owner Surr… ## 7 A635072 Beowulf 04/16/2019 … 04/16/2019 0… 415 East Mary Stree… Public Ass… ## 8 A708452 Mumble 07/30/2015 … 07/30/2015 0… Austin (TX) Public Ass… ## 9 A818975 &lt;NA&gt; 06/18/2020 … 06/18/2020 0… Braker Lane And Met… Stray ## 10 A774147 &lt;NA&gt; 06/11/2018 … 06/11/2018 0… 6600 Elm Creek in A… Stray ## # … with 132,204 more rows, and 7 more variables: intake_condition &lt;chr&gt;, ## # animal_type &lt;chr&gt;, sex_upon_intake &lt;chr&gt;, age_upon_intake &lt;chr&gt;, ## # breed &lt;chr&gt;, color &lt;chr&gt;, intake_date &lt;chr&gt; 10.6.1 Edit to convert to a real date If you did the above correctly, you should have a column called intake_date as the last column, but it isn’t actually a date yet, it is just characters that look like a date. We’ll fix that now. Edit your date-fix chunk to add another rule INSIDE your mutate. The new column will still be intake_date = but now you’ll set that to mdy(intake_date) Run the chunk and make sure that your same last column intake_date says &lt;date&gt; right below the name. The order should now be 2019-01-03. Now that this all works, assign all this using &lt;- into a tibble called date_fix. Add a glimpse() of the date_fix tibble in the same chunk so you can eyeball the results. this was simlar to converting the date in billboard date_fix &lt;- raw_data %&gt;% mutate( intake_date = str_sub(date_time, 1, 10), intake_date = mdy(intake_date) ) date_fix %&gt;% glimpse() ## Rows: 132,214 ## Columns: 13 ## $ animal_id &lt;chr&gt; &quot;A786884&quot;, &quot;A706918&quot;, &quot;A724273&quot;, &quot;A665644&quot;, &quot;A682524&quot;… ## $ name &lt;chr&gt; &quot;*Brock&quot;, &quot;Belle&quot;, &quot;Runster&quot;, NA, &quot;Rio&quot;, &quot;Odin&quot;, &quot;Beo… ## $ date_time &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ month_year &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ found_location &lt;chr&gt; &quot;2501 Magin Meadow Dr in Austin (TX)&quot;, &quot;9409 Bluegras… ## $ intake_type &lt;chr&gt; &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Owner S… ## $ intake_condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Sick&quot;, &quot;Normal&quot;, &quot;Norm… ## $ animal_type &lt;chr&gt; &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog… ## $ sex_upon_intake &lt;chr&gt; &quot;Neutered Male&quot;, &quot;Spayed Female&quot;, &quot;Intact Male&quot;, &quot;Int… ## $ age_upon_intake &lt;chr&gt; &quot;2 years&quot;, &quot;8 years&quot;, &quot;11 months&quot;, &quot;4 weeks&quot;, &quot;4 year… ## $ breed &lt;chr&gt; &quot;Beagle Mix&quot;, &quot;English Springer Spaniel&quot;, &quot;Basenji Mi… ## $ color &lt;chr&gt; &quot;Tricolor&quot;, &quot;White/Liver&quot;, &quot;Sable/White&quot;, &quot;Calico&quot;, &quot;… ## $ intake_date &lt;date&gt; 2019-01-03, 2015-07-05, 2016-04-14, 2013-10-21, 2014… Now that you can see the date_time and intake_date columns at once, check to make sure they converted correctly and you don’t have any problems. Doublecheck the datatype for intake_date, which should be &lt;date&gt;. 10.7 Parse the date into helpful variables Now that we have a good date to work with, we can use other lubridate functions to create some versions of the date that will help us down the road when we do summaries and plots. TBH, just diving into the data at this point you might not know you need these date parts yet until you try to create summaries and plots. If you find later that you need helpful columns like this, you can always come back to your import notebook, create and re-run it to get updated data. In the interest of time I’m front-loading the need based on experience. We are going to create three variations of the date to help us later: A yr column with just the year, like 2019. A mo column with the month, but using the name, like Jan. A yrmo column like 2019-01 We’ll do this in the same mutate() function, but we’ll use different methods to do each one, which is a useful learning experience. We’ll also use select() to reorder our columns to put these all at front of the tibble so we can see them. We’ll work through this out in the open so I can explain as we go along. 10.7.1 Extract the year We can use year() from lubridate to pluck the YYYY value from intake_date. We’ll use this to build our mutate. Create a new section and note we are creating helpful date parts. Add the following chunk so we can get started. date_parts &lt;- date_fix %&gt;% mutate( yr = year(intake_date) # creates yr and fills it with YYYY ) # peek date_parts %&gt;% glimpse() ## Rows: 132,214 ## Columns: 14 ## $ animal_id &lt;chr&gt; &quot;A786884&quot;, &quot;A706918&quot;, &quot;A724273&quot;, &quot;A665644&quot;, &quot;A682524&quot;… ## $ name &lt;chr&gt; &quot;*Brock&quot;, &quot;Belle&quot;, &quot;Runster&quot;, NA, &quot;Rio&quot;, &quot;Odin&quot;, &quot;Beo… ## $ date_time &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ month_year &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ found_location &lt;chr&gt; &quot;2501 Magin Meadow Dr in Austin (TX)&quot;, &quot;9409 Bluegras… ## $ intake_type &lt;chr&gt; &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Owner S… ## $ intake_condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Sick&quot;, &quot;Normal&quot;, &quot;Norm… ## $ animal_type &lt;chr&gt; &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog… ## $ sex_upon_intake &lt;chr&gt; &quot;Neutered Male&quot;, &quot;Spayed Female&quot;, &quot;Intact Male&quot;, &quot;Int… ## $ age_upon_intake &lt;chr&gt; &quot;2 years&quot;, &quot;8 years&quot;, &quot;11 months&quot;, &quot;4 weeks&quot;, &quot;4 year… ## $ breed &lt;chr&gt; &quot;Beagle Mix&quot;, &quot;English Springer Spaniel&quot;, &quot;Basenji Mi… ## $ color &lt;chr&gt; &quot;Tricolor&quot;, &quot;White/Liver&quot;, &quot;Sable/White&quot;, &quot;Calico&quot;, &quot;… ## $ intake_date &lt;date&gt; 2019-01-03, 2015-07-05, 2016-04-14, 2013-10-21, 2014… ## $ yr &lt;dbl&gt; 2019, 2015, 2016, 2013, 2014, 2017, 2019, 2015, 2020,… Look how I set up this chunk to work with it. I know that I’m going to be adding columns and checking values and it is a pain click to the end of the tibble each time to see the results. So what I’ve done is set this up to go into a new tibble called date_parts and then I glimpse that at the end so I can peek at the results. This allows me to look at the first couple of values in the glimpse to make sure I’ve done the work right. I’ll still be working one line at a time as I edit the chunk further, but at least I can see what I’m doing. Now, note we have a new column yr at that starts with “2019,” which matches what is in intake_date (and even date_time). This is good. Can you see how our mutate created the new yr column? We name the new column yr We fill that column with year(intake_date), which plucks the year from that column. 10.7.2 Extract the month name We’ll edit the same chunk to do a similar action to get the name of the month in a new column. You’ll see in a minute how we can choose to get the name of the month instead of the number. Edit your chunk to add a new line to the mutate function. Don’t forget the comma after the existing rule. Add the new line as indicated below, then run it to see the results. date_parts &lt;- date_fix %&gt;% mutate( yr = year(intake_date), # don&#39;t forget the comma mo = month(intake_date) # the new mutate rule to get month ) # peek date_parts %&gt;% glimpse() ## Rows: 132,214 ## Columns: 15 ## $ animal_id &lt;chr&gt; &quot;A786884&quot;, &quot;A706918&quot;, &quot;A724273&quot;, &quot;A665644&quot;, &quot;A682524&quot;… ## $ name &lt;chr&gt; &quot;*Brock&quot;, &quot;Belle&quot;, &quot;Runster&quot;, NA, &quot;Rio&quot;, &quot;Odin&quot;, &quot;Beo… ## $ date_time &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ month_year &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ found_location &lt;chr&gt; &quot;2501 Magin Meadow Dr in Austin (TX)&quot;, &quot;9409 Bluegras… ## $ intake_type &lt;chr&gt; &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Owner S… ## $ intake_condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Sick&quot;, &quot;Normal&quot;, &quot;Norm… ## $ animal_type &lt;chr&gt; &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog… ## $ sex_upon_intake &lt;chr&gt; &quot;Neutered Male&quot;, &quot;Spayed Female&quot;, &quot;Intact Male&quot;, &quot;Int… ## $ age_upon_intake &lt;chr&gt; &quot;2 years&quot;, &quot;8 years&quot;, &quot;11 months&quot;, &quot;4 weeks&quot;, &quot;4 year… ## $ breed &lt;chr&gt; &quot;Beagle Mix&quot;, &quot;English Springer Spaniel&quot;, &quot;Basenji Mi… ## $ color &lt;chr&gt; &quot;Tricolor&quot;, &quot;White/Liver&quot;, &quot;Sable/White&quot;, &quot;Calico&quot;, &quot;… ## $ intake_date &lt;date&gt; 2019-01-03, 2015-07-05, 2016-04-14, 2013-10-21, 2014… ## $ yr &lt;dbl&gt; 2019, 2015, 2016, 2013, 2014, 2017, 2019, 2015, 2020,… ## $ mo &lt;dbl&gt; 1, 7, 4, 10, 6, 2, 4, 7, 6, 6, 8, 10, 7, 2, 3, 2, 11,… What we get in return here is the number of the month: A “1” for January; a “7” for July, etc. What we really want is the names of the month to help us with plotting later. Edit the mutate to add , label = TRUE within the month(). date_parts &lt;- date_fix %&gt;% mutate( yr = year(intake_date), mo = month(intake_date, label = TRUE) # add the label argument ) # peek date_parts %&gt;% glimpse() ## Rows: 132,214 ## Columns: 15 ## $ animal_id &lt;chr&gt; &quot;A786884&quot;, &quot;A706918&quot;, &quot;A724273&quot;, &quot;A665644&quot;, &quot;A682524&quot;… ## $ name &lt;chr&gt; &quot;*Brock&quot;, &quot;Belle&quot;, &quot;Runster&quot;, NA, &quot;Rio&quot;, &quot;Odin&quot;, &quot;Beo… ## $ date_time &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ month_year &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ found_location &lt;chr&gt; &quot;2501 Magin Meadow Dr in Austin (TX)&quot;, &quot;9409 Bluegras… ## $ intake_type &lt;chr&gt; &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Owner S… ## $ intake_condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Sick&quot;, &quot;Normal&quot;, &quot;Norm… ## $ animal_type &lt;chr&gt; &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog… ## $ sex_upon_intake &lt;chr&gt; &quot;Neutered Male&quot;, &quot;Spayed Female&quot;, &quot;Intact Male&quot;, &quot;Int… ## $ age_upon_intake &lt;chr&gt; &quot;2 years&quot;, &quot;8 years&quot;, &quot;11 months&quot;, &quot;4 weeks&quot;, &quot;4 year… ## $ breed &lt;chr&gt; &quot;Beagle Mix&quot;, &quot;English Springer Spaniel&quot;, &quot;Basenji Mi… ## $ color &lt;chr&gt; &quot;Tricolor&quot;, &quot;White/Liver&quot;, &quot;Sable/White&quot;, &quot;Calico&quot;, &quot;… ## $ intake_date &lt;date&gt; 2019-01-03, 2015-07-05, 2016-04-14, 2013-10-21, 2014… ## $ yr &lt;dbl&gt; 2019, 2015, 2016, 2013, 2014, 2017, 2019, 2015, 2020,… ## $ mo &lt;ord&gt; Jan, Jul, Apr, Oct, Jun, Feb, Apr, Jul, Jun, Jun, Aug… How did I know to do that? I Googled get month name in lubridate. The first result took me to a lubridate.tidyverse.org page that explained how to do it. TBH, I was lucky to find the answer in the first result, but I do usually try official tidyverse pages first. I’m also used to reading their documentation. You’ll see there the default label for months is to abbreviate the month. If you wanted the long names you would also add and argument abbr = FALSE. You still need the label argument, too. We’ll stick with the short names. 10.7.3 Extract YYYY-MM format For our next challenge, we want to create a yr_mo column that has both the year and month of our date in YYYY-MM format. TBH (I have a lot of those today), we could use str_sub() to do this, but then I wouldn’t get to show you how to format dates in different ways. For this one, I think we’ll add the line first and then I’ll explain it afterward. Edit your mutate function to add yet another rule (don’t forget the comma!) Add the rule below, run it, then read about it below. Check out the last row of your glimpse to make sure the column was created and in YYYY-MM format. date_parts &lt;- date_fix %&gt;% mutate( yr = year(intake_date), mo = month(intake_date, label = TRUE), yr_mo = format(intake_date, &quot;%Y-%m&quot;) # new rule to make YYYY-MM ) # peek date_parts %&gt;% glimpse() ## Rows: 132,214 ## Columns: 16 ## $ animal_id &lt;chr&gt; &quot;A786884&quot;, &quot;A706918&quot;, &quot;A724273&quot;, &quot;A665644&quot;, &quot;A682524&quot;… ## $ name &lt;chr&gt; &quot;*Brock&quot;, &quot;Belle&quot;, &quot;Runster&quot;, NA, &quot;Rio&quot;, &quot;Odin&quot;, &quot;Beo… ## $ date_time &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ month_year &lt;chr&gt; &quot;01/03/2019 04:19:00 PM&quot;, &quot;07/05/2015 12:59:00 PM&quot;, &quot;… ## $ found_location &lt;chr&gt; &quot;2501 Magin Meadow Dr in Austin (TX)&quot;, &quot;9409 Bluegras… ## $ intake_type &lt;chr&gt; &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Owner S… ## $ intake_condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Sick&quot;, &quot;Normal&quot;, &quot;Norm… ## $ animal_type &lt;chr&gt; &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog… ## $ sex_upon_intake &lt;chr&gt; &quot;Neutered Male&quot;, &quot;Spayed Female&quot;, &quot;Intact Male&quot;, &quot;Int… ## $ age_upon_intake &lt;chr&gt; &quot;2 years&quot;, &quot;8 years&quot;, &quot;11 months&quot;, &quot;4 weeks&quot;, &quot;4 year… ## $ breed &lt;chr&gt; &quot;Beagle Mix&quot;, &quot;English Springer Spaniel&quot;, &quot;Basenji Mi… ## $ color &lt;chr&gt; &quot;Tricolor&quot;, &quot;White/Liver&quot;, &quot;Sable/White&quot;, &quot;Calico&quot;, &quot;… ## $ intake_date &lt;date&gt; 2019-01-03, 2015-07-05, 2016-04-14, 2013-10-21, 2014… ## $ yr &lt;dbl&gt; 2019, 2015, 2016, 2013, 2014, 2017, 2019, 2015, 2020,… ## $ mo &lt;ord&gt; Jan, Jul, Apr, Oct, Jun, Feb, Apr, Jul, Jun, Jun, Aug… ## $ yr_mo &lt;chr&gt; &quot;2019-01&quot;, &quot;2015-07&quot;, &quot;2016-04&quot;, &quot;2013-10&quot;, &quot;2014-06&quot;… OK, for this mutate we used the format() function, which takes two arguments: The column we are pulling from: intake_date in our case. The format that we want that date in: \"%Y-%m\". How did I know to do that? I Googled it. Sound familiar? I don’t remember exactly the terms, but I found this page that gave me enough to figure it out. I didn’t need the as.Date() part because I was already working with a date column. The funky %Y or whatever is really just a code. The link above has a list of the common ones you might use, though there are many more. Here are those common formats: Symbol Meaning Example %d day as a number (01-31) 01-31 %a abbreviated weekday Mon %A full weekday Monday %m month (01-12) 01-12 %b abbreviated month Jan %B full month January %y 2-digit year 07 %Y 4-digit year 2007 10.7.4 Reorder and drop columns OK, we have a mess of date columns all over our data now. We are done creating new ones, so let’s reorganize our data to put the date columns we want at the beginning and drop some we don’t need anymore. Edit your chunk to pipe the equation we’ve been working into a select() statement. Add that as indicated below. I’ll explain after. date_parts &lt;- date_fix %&gt;% mutate( yr = year(intake_date), mo = month(intake_date, label = TRUE), yr_mo = format(intake_date, &quot;%Y-%m&quot;) # new rule to make YYYY-MM ) %&gt;% select(intake_date, yr, mo, yr_mo, everything(), -date_time, -month_year) # peek date_parts %&gt;% glimpse() ## Rows: 132,214 ## Columns: 14 ## $ intake_date &lt;date&gt; 2019-01-03, 2015-07-05, 2016-04-14, 2013-10-21, 2014… ## $ yr &lt;dbl&gt; 2019, 2015, 2016, 2013, 2014, 2017, 2019, 2015, 2020,… ## $ mo &lt;ord&gt; Jan, Jul, Apr, Oct, Jun, Feb, Apr, Jul, Jun, Jun, Aug… ## $ yr_mo &lt;chr&gt; &quot;2019-01&quot;, &quot;2015-07&quot;, &quot;2016-04&quot;, &quot;2013-10&quot;, &quot;2014-06&quot;… ## $ animal_id &lt;chr&gt; &quot;A786884&quot;, &quot;A706918&quot;, &quot;A724273&quot;, &quot;A665644&quot;, &quot;A682524&quot;… ## $ name &lt;chr&gt; &quot;*Brock&quot;, &quot;Belle&quot;, &quot;Runster&quot;, NA, &quot;Rio&quot;, &quot;Odin&quot;, &quot;Beo… ## $ found_location &lt;chr&gt; &quot;2501 Magin Meadow Dr in Austin (TX)&quot;, &quot;9409 Bluegras… ## $ intake_type &lt;chr&gt; &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Stray&quot;, &quot;Owner S… ## $ intake_condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Sick&quot;, &quot;Normal&quot;, &quot;Norm… ## $ animal_type &lt;chr&gt; &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Cat&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog&quot;, &quot;Dog… ## $ sex_upon_intake &lt;chr&gt; &quot;Neutered Male&quot;, &quot;Spayed Female&quot;, &quot;Intact Male&quot;, &quot;Int… ## $ age_upon_intake &lt;chr&gt; &quot;2 years&quot;, &quot;8 years&quot;, &quot;11 months&quot;, &quot;4 weeks&quot;, &quot;4 year… ## $ breed &lt;chr&gt; &quot;Beagle Mix&quot;, &quot;English Springer Spaniel&quot;, &quot;Basenji Mi… ## $ color &lt;chr&gt; &quot;Tricolor&quot;, &quot;White/Liver&quot;, &quot;Sable/White&quot;, &quot;Calico&quot;, &quot;… Alright, that is a helluva a select statement. The only new thing there is everything(), which selects (you guessed it) everything not already named. The selects come in order, so it works like this: select the intake_date, yr, mo, yr_mo select everything else remove date_time and month_year, which we don’t need anymore 10.8 On your own: Filter dates You’ve filtered data by date several times before, so you can do this on your own. It will affect all your work later, so you’ll want to check your work. Here are the directions and some hints: Our data goes back in time to 2013. We only want years 2016 and newer. Filter out the older data. We don’t want the partial month of October 2021 as it is not a full month. Filter out that data. Save your filtered data into a new tibble. Check your data to make sure it is right using summary() 10.9 On your own: Export your data We’re separating the import/cleaning from the rest of our analysis so we don’t have to rerun that code all the time. We did the same with Billboard and Military Surplus assignments. As such, you can handle this one on your own as well, with this guidance: Export your data as an .rds file into your data-processed folder. Name the file starting with 01- so you can tell later where it came from. The rest of the name is up to you, but make sure it is in the right place and remember the name so you can open it in the next notebook. 10.10 Set up your analysis notebook Set up a new notebook and call it 02-analysis.Rmd Create a setup section and load the following libraries: library(tidyverse) library(lubridate) library(scales) library(plotly) library(clipr) You might have to use install.packages() for the “scales” library, I’m not sure. You should have clipr from the last chapter. For the love of your favorite deity (or none at all), please please please remember to run your libraries each time you open your notebook to work on it. That tripped up several folks over the past couple of weeks. Restart R and Run All Chunks is your friend. 10.11 On your own: Import your cleaned data Yep, set up a new section Import your data from the last notebook. You should be using read_rds() Save the imported data into a tibble called intakes so we are all on the same page. 10.12 Question 1: Intakes by year Our question is: Are animal intakes increasing or decreasing each year since 2016? Plot a column chart of intakes by year. Don’t include 2021 since it is not a full year. Remember that we break these plots into two parts: Summarize your data Plot your data While I have not problem with you using group_by/summarize/arrange for this, this assignment is all about counting rows, so I think it is worth revisiting the count() function. Take a quick review of the count function from Bilboard. With that in mind, write a summary that counts the number of rows for each year. Remember we have the yr column we created earlier. Create a new section about “Intakes by year.” Build a summarize table that counts rows by year. Name your counted column count_animals. Filter out any results from 2021 since that is not a full year. Save the result into a tibble called intakes_yr_data. Don’t overthink it intakes_yr_data &lt;- intakes %&gt;% count(yr, name = &quot;count_animals&quot;) %&gt;% filter(yr &lt; 2021) # peek at it intakes_yr_data ## # A tibble: 5 × 2 ## yr count_animals ## &lt;dbl&gt; &lt;int&gt; ## 1 2016 17675 ## 2 2017 17563 ## 3 2018 16979 ## 4 2019 19727 ## 5 2020 9585 10.12.1 On your own: Column chart of intakes by year You’ve built column charts before for princesses and ice cream. No need to flip the coordinates on this one. Here I want you to build a column chart based on the data you just made, and I want you to make it as complete as possible. Plot a geom_col chart using yr on the x axis and count_animals on the y axis. Include labs for title, subtitle, caption and good axis names Again, no need to flip the axis. Year can stay along the bottom. Once you’ve built the chart, what does it tell you? I’m sure you can guess what happened in 2020, but to be sure you would want to do some reporting and talk to the animal center to learn how they dealt with the pandemic. 10.12.2 Getting commas on numbers One thing you might notice different about my example chart is I have commas in the values on the Y axis and within the text labels. It’s a common need and there is a solution, and why we’ve installed and loaded the “scales” library: Add the following as a new layer on your chart, but don’t forget the + on the line above: scale_y_continuous(labels = comma) Run that and make sure it works. For the numbers as labels, in your geom_text() layer you can wrap your aes(labels = count_animals) in a comma() function. In your geom_text() layer, edit the aes to this: label = comma(count_animals). 10.13 Question 2: Intakes by month Are there seasonal monthly trends in overall animal intakes? Plot intakes by month from 2016 to current, including 2021. (One long line or a column chart.) To find this answer we’ll plot as a single line chart and along the way we’ll learn how to rotate our x axis labels. 10.13.1 Intakes by month as a line We need our data first. To show every month on one chart we have to know how many animals were brought in by both year and month. This is why we created the yr_mo column earlier. This time we can keep the data from 2021. Create a new section noting you are plotting by month as a line. Use count() to summarize the data by the yr_mo column. Name your new column count_animals. Assign the result to a new oblject using &lt;- named intakes_yrmo so we are on the same page. I’m too nice intakes_yrmo &lt;- intakes %&gt;% count(yr_mo, name = &quot;count_animals&quot;) # peek intakes_yrmo ## # A tibble: 69 × 2 ## yr_mo count_animals ## &lt;chr&gt; &lt;int&gt; ## 1 2016-01 1216 ## 2 2016-02 1194 ## 3 2016-03 1419 ## 4 2016-04 1560 ## 5 2016-05 2037 ## 6 2016-06 1634 ## 7 2016-07 1409 ## 8 2016-08 1653 ## 9 2016-09 1539 ## 10 2016-10 1387 ## # … with 59 more rows Now that you have the data, we’ll try to plot this as a line. You might end up with this error: “geom_path: Each group consists of only one observation. Do you need to adjust the group aesthetic?” intakes_yrmo %&gt;% ggplot(aes(x = yr_mo, y = count_animals)) + geom_line() ## geom_path: Each group consists of only one observation. Do you need to adjust ## the group aesthetic? The geom_line() function expects you to have more than one line to plot, and when we don’t have that (and often when we do) we have to specify the “group” or value to split the lines. When we have only one line we need to specify that: Edit your geom_line() function to add group = 1 inside it. intakes_yrmo %&gt;% ggplot(aes(x = yr_mo, y = count_animals)) + geom_line(group = 1) # group added here OK, but we can’t read the X axis names, and it wouldn’t make sense to flip the whole line chart, so intead we’ll flip the axis names. Remember that we can change just about anything in the theme, right? Add the layer noted below to your plot. Don’t forget the + on the previous line. intakes_yrmo %&gt;% ggplot(aes(x = yr_mo, y = count_animals)) + geom_line(group = 1) + theme(axis.text.x = element_text(angle = 90)) # flips the axis name You can change the number there to get different angles, like 45 degrees. How the heck did I know that? Can you guess? Yes, Google is your friend, searching for something like “rotate axis names in ggplot.” To be honest, in this case I used a different method: I phoned a friend for help and Jo Lukito found this. She should’ve chided me with Let me Google that for you. She also helped me with the next challenge. 10.13.2 Make the chart wider Our chart is still too squished to read. For this one, the answer is in the R chunk settings so I can’t show you in code with this book. In your R chunk where you name the chunk like this: {r chunk-name}, edit it to say {r chunk-name, fig.width = 7} and then run it. Hopefully you have a more descriptive name chunk than chunk-name, though. Unfortunately that change doesn’t really show in this published book but it does help you in your own R Notebook. 10.13.3 So, what of this We could plot this same data as a geom_col() but it would have the same issues. That said, we’ve proven two things here: There is definitely a seasonal trend to animal intakes. There seem to be surges each spring and early summer, between March and June, We’ve also proved this is a crappy way to see that. Let’s find another way. No need to clean up that line chart beyond what we’ve done, but keep it in your notebook. 10.14 Question 3: Intakes by month, split by year Plot that same monthly trend, except with month as the x axis, with a new line for each year. Let’s visualize success so we know what we are going after. This is the basic plot before being cleaned up. Here we can see each year by month all on the same scale and see that the lowest year by far was 2020, and 2021 is trending back up but doesn’t yet reach the level of previous years. To make this chart you need the mo column that we created earlier so we can plot our months across the X axis. The brilliant thing we did was build that month from a real date so it retains its factor order of Jan, Feb, etc., instead of being alphabetical. But we also need the yr column so we can set the group and color of the lines by that year. So well be grouping by two values. We’ll be counting rows as we have been and name them count_animals. We’ll do this one together, but you’ll have to build a similar chart in a bit so pay attention. 10.14.1 Prepare the data with mo and yr Start a new section that you are plotting intakes by month, split by year Add the R chunk below mo_yr_data &lt;- intakes %&gt;% count(mo, yr, name = &quot;count_animals&quot;) # peek mo_yr_data ## # A tibble: 69 × 3 ## mo yr count_animals ## &lt;ord&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Jan 2016 1216 ## 2 Jan 2017 1216 ## 3 Jan 2018 1123 ## 4 Jan 2019 1240 ## 5 Jan 2020 1215 ## 6 Jan 2021 567 ## 7 Feb 2016 1194 ## 8 Feb 2017 1202 ## 9 Feb 2018 1044 ## 10 Feb 2019 1131 ## # … with 59 more rows 10.14.2 Plot by month, split by year So we have this month name mo to plot along the X axis and the count_animals to plot along the Y axis. We have yr_mo to group our lines. Note that you are plotting now Add the base chart as noted below. mo_yr_data %&gt;% ggplot(aes(x = mo, y = count_animals)) + # sets our x,y geom_line(aes(group = yr)) # separates the lines We are getting somewhere. We can see each year on the plot, but we can’t tell them apart. Inside the aes() for geom_line(), add color = yr. mo_yr_data %&gt;% ggplot(aes(x = mo, y = count_animals)) + # sets our x,y geom_line(aes(group = yr, color = yr)) # adds color to lines based on yr Well, that is an interesting color choice for our years. Ggplot is using the yr value as a continuous number, and indeed if we look back up at our data we can see the column datatype is &lt;dbl&gt; which means it is a number. That happened way back when we created the yr column. What to do? We could go back to the import/clean notebook and adjust that to make it a character datatype. Or we could go to our data prep step and mutate that column there. Or we could just fix it in the chart. We’ll just fix it in the chart. 10.14.3 Adjust the yr value to a character In your plot code, find the color = yr part and change it to color = as.character(yr) mo_yr_data %&gt;% ggplot(aes(x = mo, y = count_animals)) + geom_line(aes(group = yr, color = as.character(yr))) # color = yr updated What we’ve done is used the as.character() function to change the yr value from a number to text. Now ggplot thinks it is a category instead of a continuous number. If this came up again, we might go back to the import notebook and fix it, but this works for now. But do note that also changed the label for our legend. We needed to fix that anyway and we can do that with labs() the same way we edit our x and y axes labels. Just use color = \"Year\" or whatever you want call it. 10.14.4 Clean up your intakes by month, split by year chart Edit your plot code to do the following: Add a title and subtitle Add the source of our data in the caption Clean up your axis and color names 10.15 Question 4: Animal types by month Do certain types of animals drive seasonal trends? Use five full years of data (not 2021) to summarize intakes by animal type and month. Plot with month on the x axis with a line for each animal type. To envision success, just look at the chart you just made. Instead of having a line for each year, we want a line for each animal type. Before we get there, let’s take a look at those animal types. 10.15.1 Recode animal types Create a section that you are plotting animal types by month Create a quick count() on the column animal_type. I’ll wait. You need to do the code in your notebook, but here is the output: ## # A tibble: 5 × 2 ## animal_type n ## &lt;chr&gt; &lt;int&gt; ## 1 Bird 513 ## 2 Cat 34242 ## 3 Dog 50662 ## 4 Livestock 18 ## 5 Other 4864 Note that there are way more Dogs and Cats than other animal types. We will create a new tibble that renames each row with Bird or Livestock as Other so they will all be in the same category. We do this with recode() within a mutate(). You can read about recode here. If you read that you’ll notice there is a weird thing in that it bucks the R trend of naming new things first and then filling them. Recode names the old thing first and then defines the new name. Oh, well. It’s what we got. Our recode will happen inside a mutate() function but let’s talk about recode() first. The first argument is the column you are recoding: recode(animal_type) Next we give it a list of the values we want to change, then set it equal to the value we want it to be: recode(animal_type, \"Old Value\" = \"New Value\"). We can stack the changes inside recode. Write a markdown note that you are going to recode animal_type. Add the code block below, run it, then read the explanation. intake_types &lt;- intakes %&gt;% filter(yr &lt; 2021) %&gt;% # removes 2021 because its partial yr mutate( animal_type = recode(animal_type, # first arg is the column to look at &quot;Bird&quot; = &quot;Other&quot;, # old name, then new name &quot;Livestock&quot; = &quot;Other&quot; # old name, then new name ) ) intake_types %&gt;% count(animal_type) ## # A tibble: 3 × 2 ## animal_type n ## &lt;chr&gt; &lt;int&gt; ## 1 Cat 30474 ## 2 Dog 46222 ## 3 Other 4833 Let’s break this down: At the top We started with our data and assigned it to a new tibble. We don’t want to change the original data. We start a mutate. We set it to change the original animal_type column with our recoded values. Within the recode() function we say with column we are chaning (animal_type) and then we note the old and new values, each in quotes. At the bottom we take the new tibble and pipe it into a count(animal_type) so we can check the results. Note that the changed data is still row-level data for each animal. We just piped that result into count() so we could check the recode changes. We didn’t “save” that last count. Like I did with the date parts earlier, when I built this I went ahead and started by assigning the original data to a new tibble and then printing that new tibble before I worked on the rest line-by-line. Recode is a valuable method to clean data, but you have to be careful that you aren’t overwritting your original data. I was comfortable doing so because we could easily eyeball the results to ake sure they were right, and we were saving the result into a new tibble anyway, so the original data is safe in intakes. 10.15.2 On your own: Count animal types by month Now it is time for you to prep this data for our plot. Here is the logic: You are counting the rows by both the month mo and the animal_type. Remember to start with the 1intake_types` tibble you just created. Write notes that you are creating the animal type summary by month Write code that counts the rows based on month and animal type. Name your new column something that makes sense. You should end up with a summary with three columns: mo, animal_type and whatever you named the count column. 10.15.3 On your own: Plot animal types by month Remember this is very similar to your plot above where you made a line chart of counts split by year, but this time you are splitting by animal_type. Write notes that you are plotting Build the plot and include all the labs: title, subtitle, caption and fix the axis and color names. One thing about describing this chart in your subtitle: You have to describe in your own words that this chart combines counts by each month over five years: 2016-2020. It’s a nuance a reader needs to understand. What did you learn about your plot? Is there a type of animal that drives that spring/summer surge? Tell me in text in your notebook how you might find out why that is so. 10.16 What we learned We learned how to download data from the City of Austin’s data portal. We just scratched the surface there. We cleaned our date using str_sub() and extracted date parts with year() and month() and used format() to pull a date part in a specific way. We used count() to make some summaries. Remember this is the shortcut for group_by/summarize/arrange (GSA) that can only count rows and not do any other math. But it is damned handy. We prepped data and plotted to find answers to specific questions. We learned how to add commas to axis names in ggplot with the scales package using. We used recode() to update some values in our data. 10.17 Turn in your work Make sure all your code runs fresh and knit it Stuff the folder and submit it to canvas 10.18 What’s next I had planned on adding some more Datawrapper practice with this data which requires some pivoting, so keep this project around. We may revisit it. "],["census-intro.html", "Chapter 11 Census introduction 11.1 Goals of this chapter 11.2 Start a tidycensus project 11.3 Census data portal and API 11.4 About the tidycensus package 11.5 Broadband access by county in Texas 11.6 Using the tidycensus load_variable() function 11.7 Use tidycensus to fetch our data 11.8 Map broadband access by counties in Texas 11.9 Keep this project 11.10 What we’ve learned 11.11 Other useful census-related packages 11.12 Interactive maps with leaflet 11.13 More resources and examples 11.14 Using the data portal to download data", " Chapter 11 Census introduction The U.S. Census Bureau has a wealth of data that can help journalists tell stories. This chapter is not a comprehensive guide on how to use it, but instead an introduction on some ways you can. There is a recorded lecture in Canvas that covers different data programs within the census, so you should watch that before embarking on this. You do need some basic knowledge of those programs for this to make sense. 11.1 Goals of this chapter Introduce the official U.S. Census Bureau site data.census.gov. Explain API keys and set them up for census data. Introduce and explore the tidycensus package to pull census data into R. Introduce some mapping techniques using tidycensus. Note some other packages and methods to use census data. 11.2 Start a tidycensus project Start a new project called yourname-census. Start a new R Notebook and title it broadband.Rmd. Install tidycensus in your Console: install.packages(\"tidycensus\") Create a setup section with the following libraries library(tidyverse) library(tidycensus) library(scales) 11.3 Census data portal and API Before we dive in, we need to do some setup for your machine. The Census Bureau has a data portal data.census.gov where you can search for and download data, but the site is … lacking. There is so much data it can be overwhelming at first. But once you’ve gained experience with the different programs and offerings it gets easier to find what you want. We’ll use the official portal to find our data, but I also want to give a shoutout to CensusReporter, a tool built by journalists for journalists looking for finding census data. But for now, we’ll use data.census.gov. But what we are really here to learn is how to import Census Bureau data directly into R through using their Application Programming Interface, or API. API’s let programming languages like R talk to other systems and request responses, typically through a URL. Packages like tidycensus, which we’ll explor here, help us do that behind the scenes. There are a number of packages that do this with the census API, and they each work a little differently to solve different challenges. Manually downloading census data is usually a multiple-step and multiple-decision process. An advantage to using the API is you can script that decision-making process for consistency. It’s transparent and repeatable. The Census requires a free API key to use their service. It’s like your personal license, and should not be shared with others. We do NOT write our API key into our R Notebooks. If you do not already have a Census API Key or have not installed in yet into your R environment, follow these steps: 11.3.1 Request a key (I may ask you to do this before we get into this chapter. If I do, then you already have your key.) Sign up for an API key here. You should get an email back within a few minutes that includes a long string of random numbers and letter and a link to activate the key. Do activate that key through the link in the email. 11.3.2 Install a key In your Console (NOT in Markdown) enter the code below, but replace your_key_here with the key you got in the email. Keep the quotes there. census_api_key(&quot;your_key_here&quot;, install = TRUE) Next you’ll need to reload the environment. In your Console do this: readRenviron(&quot;~/.Renviron&quot;) You can check to make sure it is working by running the following in your Console: Sys.getenv(&quot;CENSUS_API_KEY&quot;) Which should return your API key string. That just let’s you know it is working. You only have to set up your API key once on each machine. Once installed, it gets automatically loaded when you restart R. Here is more explanation on saving keys if you need it. 11.4 About the tidycensus package Kyle Walker is a professor at TCU who developed the tidycensus package to return census data in tidyverse-ready tibbles with options to include spatial geometry to make maps. He is also writing a book Analyzing US Census Data. Basically, it’s brilliant. There is excellent documentation on using tidycensus. In this chapter we’ll walk through searching through data, fetching data and making a map. 11.4.1 Finding the data you want To get data through tidycensus you need to know the “census program” and the specific “variables” or data points you want and there are thousands of these IDs across the different Census files. To be honest, I find this the hardest part of the process. We can use a function in tidycensus called load_variables to help find what we need, but we must know what “program,” the “year” and sometimes the “product” our data is in before we can use it to find our specific data. I’ve found the best way to start this process is to find the data you want on data.census.gov first, which we’ll walk through in a moment. We’ll start by using the American Community Survey (ACS) program. The survey comes in 5-year and 1-year versions. The 1-year version is more current, but is limited in geographies available. The 5-year version has more data, but it encompasses 5-years of answers. See the lecture for more on that. We’ll uses the 5-year versions for . To access a 5-year data set, we use the last year of the data, so we use “2019” for the 2015-2019 5-Year ACS, which is the most recent release. Just to make it more complicated (sorry), there are different “products” within the ACS: Detailed Tables, Subject Tables and Data Profiles. Finding the variables is the hardest part of this exercise, I think. 11.5 Broadband access by county in Texas Here is our first challenge: What counties in Texas have the highest percentage of households with broadband access of any type. Here is how we go about finding what we need: Go to http://data.census.gov. In the search box there, search for “broadband access” The first Table results should be “TYPES OF COMPUTERS AND INTERNET SUBSCRIPTIONS.” Click on that table to open it. Click on the dropdown at top right (indicated below) and change it to “2019 ACS 5-Year Estimates Subject Table.” (We use the 5-year version so we can get results for every county in Texas. The 1-year version would only have larger counties.) If you have trouble finding the table, you can get it here. Broadband table The default view of this table shows us values for this data across the entire US. This particular table has both Total values (the estimate) and the the Percent values (which is a percentage of that variable vs Total Households, the “univerise” of our data shown on the first line of data.) The values we want for this is the one I’ve underlined above with the red line … it is the Percent of households with Broadband of any type. Before we can ask for our data through the API, we need to find the exact variable name for this value, but that isn’t shown here on the table (damnit.) But we’ll use the information on this screen to find it. 11.6 Using the tidycensus load_variable() function Looking at my marked up screenshot above, I look for several things when I’m trying to get data: I look at the table name: S2801 I look at the “Product” line in the result. It will say something like “2019 ACS 5-Year Estimates Subject Table”. It is the last two words in this line we are looking at to determine the program. Here is a schematic of the difference. Product tidycensus value Details Detailed Tables “acs1” or “acs5” Tables about specific subjects or characteristics. Typically estimates and margin of errors only. Subject Tables “acs5/subject” Topic-based collections. Has both estimates and percentages. Data Profiles “acs5/profile” Specific collections around social, economic, housing and demographic areas. Can have both estimates and percentages. Here we’ll use the load_variables() function again, but we have to specify that we are looking at acs5/subject tables since that is the program we are using. Create a new section that you are finding our broadband variable. Add the code below and run it. v19_subject &lt;- load_variables(2019, &quot;acs5/subject&quot;, cache = TRUE) The first item v19_subject is the R object we are filling. We start with load_variables() and the first argument is the year of data that we want. Fo us this is: 2019. The second argument is the profile type: acs5/subject for the subject tables. The third argument cache = TRUE saves this table to your computer so it doesn’t download it each time you view it. Once you have saved the table into an object, you’ll see it listed in your Environment pane. Click on the little table icon on the right side to open it as a table: Open table Once you have the table open: Click on the Filter box and put in our table id under name: S2801. That filters the results to just the table we want. Under label type in “broadband,” which will further filter the table just to rows that have that term. We are looking for rows that start with “Estimate!!Percent” and we want the one that ends with “!!Broadband of any type.” It happens the be the first Percent result if you haven’t reordered the table accidently. If you hover over the label column and leave your cursor there, you’ll get a pop-up that shows you the value. Once you find the row you need, you copy the name value for that row. The one we need is S2801_C02_014. Copy that value and then add it as a Markdown note in your notebook so you have it saved there. Broadband filter I swear this is the hardest part of this. I wish there were an easier way, but I haven’t found one. Believe me, I’ve asked around about it. 11.7 Use tidycensus to fetch our data Now that we have the variable we are looking for, we’ll grab that value for the U.S. so we can make sure we have the right thing. To fetch data from the ACS program we use a the function get_acs(). It needs at least three things: The year of the dataset. For us this is 2019. The variable (or variables) you seek. For us that is S2801_C02_014. We’ll also name for clarity. The geography scope of the data. We’ll first use us to check we have the right thing. Start a new section and note you are getting the broadband percent data. Add the following chunk and run it. get_acs( year = 2019, variables = c(broadband = &quot;S2801_C02_014&quot;), geography = &quot;us&quot; ) ## Getting data from the 2015-2019 5-year ACS ## Using the ACS Subject Tables ## # A tibble: 1 × 5 ## GEOID NAME variable estimate moe ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 United States broadband 82.7 0.1 Now for a very important step: Check the values you got back for estimate and compare it to the value you want from the table you got on data.census.gov. The estimate should be “82.7,” which is the percentage of households throughout the US that have broadband access of any type. If you don’t have the right number, then you don’t have the correct variable. Make sure that is S2801_C02_014. 11.7.1 Get broadband rates by county in Texas Now that we have confirmed we have the right data, we can get this for Texas counties. Create a subsection or otherwise note you are getting broadband for Texas counties. Add the chunk below and run it and then I’ll explain after get_acs( year = 2019, variables = c(broadband = &quot;S2801_C02_014&quot;), geography = &quot;county&quot;, # we changed this to county state = &quot;TX&quot; # We&#39;ve added state to filter to just Texas ) ## Getting data from the 2015-2019 5-year ACS ## Using the ACS Subject Tables ## # A tibble: 254 × 5 ## GEOID NAME variable estimate moe ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 48001 Anderson County, Texas broadband 67.9 3 ## 2 48003 Andrews County, Texas broadband 86.2 3.2 ## 3 48005 Angelina County, Texas broadband 82.3 1.7 ## 4 48007 Aransas County, Texas broadband 81.8 3.6 ## 5 48009 Archer County, Texas broadband 75.4 3.4 ## 6 48011 Armstrong County, Texas broadband 81.6 4.8 ## 7 48013 Atascosa County, Texas broadband 80.2 2.5 ## 8 48015 Austin County, Texas broadband 74.3 2.8 ## 9 48017 Bailey County, Texas broadband 70.5 5.8 ## 10 48019 Bandera County, Texas broadband 81.8 3.1 ## # … with 244 more rows Here is what we’ve done here: We have the same get_acs() function with the same year and variables. We changed the geography argument to “county” which will give us this same variable for every county in the country. But we don’t want that so … We added a state = \"TX\" argument to get just Texas counties. Your list should start with Anderson County, Texas. 11.7.2 On your own: Arrange to get lowest/highest values We’re going to save the result above into a new R object and then use that to get the two lists: The counties with the most access, and those with the least. Edit your chunk to save the get_acs() code into a new object called broadband_tx. Run it so the object is created. Write a bit of markdown that says you are getting the counties with the lowest access. Write a block that takes broadband_tx and arranges it by the estimate, which will put the lowest access at the top. Pipe that into head(10) to see just the top values. Write a bit of markdown that says you are getting the hightest access and then a block to arrange by estimate in descening order. Pipe that into head(10) as well. 11.7.3 What you have here If you were writing a story about broadband access, you could note the counties that have the least and most access. Getting the data answer was easy once you have the variable, right? Now to blow your mind a little. 11.8 Map broadband access by counties in Texas Walker’s tidycensus package can also bring in spatial files with a single additional line of code, which allows us to map data using ggplot’s geom_sf() function. Make a new section and note that you are mapping broadband access. Add the code chunk below and run it. I’m suppressing the output here because it doesn’t show well in the book. broadband_tx_geo &lt;- get_acs( year = 2019, variables = c(broadband = &quot;S2801_C02_014&quot;), geography = &quot;county&quot;, state = &quot;TX&quot;, geometry = TRUE # this is the only new line ) broadband_tx_geo We’ve added ONE LINE of code here that gives us the geometric shapes for each county in our data. I saved this into a new tibble for clarity. 11.8.1 Plot the broadband map We’ll plot the map here, and it looks like a lot, so I’ll explain each part afterward. I really suggest that you build this one line or section at a time. You’ll see me do that in the screencast (I hope). ggplot(broadband_tx_geo) + geom_sf(aes(fill = estimate), color = &quot;white&quot;, size = .1) + theme_void() + labs( title = &quot;Broadband access in Texas counties&quot;, caption = &quot;Source: Census Bureau/ACS 5-year 2019&quot; ) + scale_fill_distiller( palette = &quot;Oranges&quot;, direction = 1, name = &quot;% households\\nwith broadband&quot; ) + theme(plot.margin = unit(c(10,0,10,0), &quot;pt&quot;)) Let’s go through it line by line: We start with ggplot and fill it with our data. We add geom_sf, which stands for shapefile. We add an aes() of fill = estimate, which is the column in our data that has the median family income. At this point, we have a map! The rest is just improving it. In addition to the geom, I added color = \"white\" which changes the color of the lines around the counties. I also added size - .1 to make them thinner. theme_void() removes the grid lines and axis names. It is pretty much used only with maps. We add our labs() which you should be familiar with now. Then we add scale_fill_distiller() with a bunch of settings. I’ll be honest, I only know of this scale because of a some tutorial that I have since lost. But let’s walk through the options used here: palette = \"Oranges\" changes the colors since I didn’t like the default blue. You could try some of these? I googled to find that. direction = 1 reverses the colors so higher numbers are darker instead of lighter. It makes more sense that way, at least to me. name = \"% households\\nwith broadband\" update the name on the legend. Note the weird \\n in the middle with creates a new line with the legend so the name isn’t so long. The last theme(plot.margin) line adds some margins around the plot since theme_void() removes all of that. I found that here. The number order is clockwise: top, right, bottom, left. 11.8.2 You did it! So you have a map of the broadband access by county for Texas. Getting the data from tidycensus into R is pretty sweet, but it does take a get getting used to. I can tell you it is still easier than downloading CSV data and filtering and selectiong for what you need. And the mapping is just fun. 11.9 Keep this project We’ll use this project in the next chapter, too. 11.10 What we’ve learned We used http://data.census.gov to find interesting data. There is way more to explore there. You set up your computer with a U.S. Census API key. We’ve explored the tidycensus package by Kyle Walker to fetch data using the Census API. You made a map! The rest of this chapter is just for your information. You don’t need to do anything with it. 11.11 Other useful census-related packages 11.11.1 The censusapi package Hannah Recht now of Kaiser Health News developed the censusapi package to pull data directly from the Census Bureau into R. See that site for more examples and documentation on use. Below is an example code chunk from censusapi that pulls the median income estimate (B19013_001E) and margin of error (B19013_001M), but I’m also including the total population for the county with B01003_001E, which was not in the “B19013” table. This is another advantage to using the API, as we are pulling from multiple tables at once. To do this manually, we would have to search for and download two separate data sets and merge them. tx_income &lt;- getCensus(name = &quot;acs/acs5&quot;, vintage = 2017, vars = c(&quot;NAME&quot;,&quot;B01003_001E&quot;, &quot;B19013_001E&quot;, &quot;B19013_001M&quot;), region = &quot;county:*&quot;, regionin = &quot;state:48&quot;) Which ends up looking like this: state county NAME B01003_001E B19013_001E B19013_001M 48 199 Hardin County, Texas 55993 56131 3351 48 207 Haskell County, Texas 5806 43529 6157 48 227 Howard County, Texas 36491 50855 2162 This gives us data in a different “shape” than the tidycensus package. It adds new variables as a column as “wide” data instead of new rows in “long” data, which is what tidycensus does. This censusapi example I have goes through a use of censusapi and finishes out by pulling data form Kyle Walker’s tigris to make a median income map. If you already have the Census data, or perhaps data that is not from the census but has a county name or one of the other geographic code values, then you can use Walker’s tigris package to get just the shapefiles. That censusapi notebook also includes use of the tigris package, if you want to see that. 11.12 Interactive maps with leaflet You can also create interactive maps in R. Here is a tutorial that walks through creating an interactive map of median income by census tract using the leaflet, mapview, tigris and acs packages. It’s a pretty basic map best used for exploration, but it’s pretty neat and not too hard to make. 11.13 More resources and examples Some other resources not already mentioned: R Census guide Mapping Census Bureau Data in R with Choroplethr by package creator Ari Lamstein Using the R Package RankingProject to Make Simple Visualizations for Comparing Populations by former Census Bureau statistician Jerzy Wieczorek Baltimore Sun example story and code. Christine Zhang says “Sometimes I prefer the output of one over the other (censusapi vs tidycensus) which is why I alternate. Spatial Data Science with R Tutorial. Not a tutorial but but this post by Timo Grossenbacher is an explanation and inspiration on how far you can take R in mapping. Here is a version that uses U.S. Census Bureau data. 11.14 Using the data portal to download data When you download a table from the data.census.gov portal, you get a stuffed archive with three files. Here is an example from a 5-year ACS data set for table B19013, which includes median income data: ACSDT5Y2017.B19013_data_with_overlays_2019-04-20T000019.csv is the data. It contains two header rows (arg!) with the first row being coded values for each column. The second row has long descriptions of what is in each column. ACSDT5Y2017.B19013_metadata_2019-04-20T000019.csv is a reference file that gives the code and description for each header in the data. ACSDT5Y2017.B19013_table_title_2019-04-20T000019.txt is a reference file with information about the table. If data is masked or missing, this file will explain the symbols used in the data to describe how and why. The first part of the file names include the program, year and table the data comes from. At the end of the file name is the date and time the data was downloaded from the portal. 11.14.1 Importing downloaded data When I import this data into R, I typically use the read_csv() function and skip the first, less-descriptive row. The second row becomes the headers, which are really long but explain the columns. I then rename them to something shorter. If you are only using selected columns, then you might use select() to get only those you need. Here is an example: tx_income &lt;- read_csv(&quot;data-raw/ACSDT5Y2017.B19013_2019-04-20T000022/ACSDT5Y2017.B19013_data_with_overlays_2019-04-20T000019.csv&quot;, skip = 1) %&gt;% rename( median_income = `Estimate!!Median household income in the past 12 months (in 2017 inflation-adjusted dollars)`, median_income_moe = `Margin of Error!!Median household income in the past 12 months (in 2017 inflation-adjusted dollars)` ) %&gt;% clean_names() Which yields this: id geographic_area_name median_income median_income_moe 0500000US48199 Hardin County, Texas 56131 3351 0500000US48207 Haskell County, Texas 43529 6157 0500000US48227 Howard County, Texas 50855 2162 11.14.2 Fields made to join with other data Pay attention to fields named id or geoid or similar names as these are often fields meant to be joined to other tables. Many use parts of FIPS codes that define specific geographic areas, and allow you to match similar fields in multiple data sets. This is especially important when it comes to mapping data, as these codes are how you join data to “shape files,” which are a data representation of geographic shapes for mapping. While we won’t go into a lot of detail about maps in this lesson, I’ve linked some examples below. You may find you want to join data based on geography names, in which case you might need to use dplyr tools to split and normalize those terms so they match your other data set, like changing “Travis County, Texas” to just “Travis.” "],["census-more.html", "Chapter 12 Joining census data 12.1 Goals of the chapter 12.2 Questions we’ll answer 12.3 Set up your notebook 12.4 New York Times COVID data 12.5 Get county populations using tidycensus 12.6 About joins 12.7 Create our rate columns 12.8 Mapping the rates for Texas counties 12.9 On your own: Map the deaths per 1,000 12.10 What we’ve learned 12.11 Turn in your work", " Chapter 12 Joining census data In the last chapter we introduced U.S. Census Bureau’s data.census.gov and used it to guide us in using their API with the tidycensus package. We used tidycensus to pull data and we mapped it. In this chapter we’ll use tidycensus again, but we’ll use it to pull data that compliments other data (COVID cases), joining two data sets together to get a per-population rate. 12.1 Goals of the chapter Introduce the New York Times’ collection of COVID-related data. Along the way we’ll learn how to use slice() to get a subset of data. Use tidycensus to pull 2020 Decennial Census population data. Introduce the concept of “joining” data on a common key variable. Create COVID cases and death rates using the combination of these two data sets. Map the results. 12.2 Questions we’ll answer Which counties in Texas have the highest/lowest cases-per-population rates for COVID. Which counties have the highest/lowest deaths-per-population rates for COVID. 12.3 Set up your notebook We’re going to use the same project from the last chapter, yourname-census, but start a new notebook. Open your census project Start a new R Notebook and name it covid-rates.Rmd. Create a setup chunk with the following libraries library(tidyverse) library(tidycensus) library(scales) library(janitor) 12.4 New York Times COVID data The New York Times has been collecting COVID-19 case data since the beginning of the pandemic, and they have been publishing it on Github for others to use. One of files they publish is cumulative case and death counts by county throughout the United States. We will use this file, along with 2020 U.S. Census Bureau population data, to create cases-per-population and deaths-per-population rates for each county in Texas. Because counties have varying populations, we need a rate like this to compare them on an equal basis. 12.4.1 On your own: Import the NYT data We won’t bother to save the covid data to your hard drive … we’ll just import directly from the URL. Create a new section and note you are download the NYT covid data Start an R chunk and use read_csv to import the data from this url: https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv and save it into an R object called covid. (This is similar to how you imported the Skittles data.) Print your new covid tibble to the screen. You can pipe it into head() to show just the top of it so we can see what it is. There is more than 1.8 million rows of this data, so it might take a couple of seconds. Let’s tour the data real quick: covid %&gt;% head() ## # A tibble: 6 × 6 ## date county state fips cases deaths ## &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2020-01-21 Snohomish Washington 53061 1 0 ## 2 2020-01-22 Snohomish Washington 53061 1 0 ## 3 2020-01-23 Snohomish Washington 53061 1 0 ## 4 2020-01-24 Cook Illinois 17031 1 0 ## 5 2020-01-24 Snohomish Washington 53061 1 0 ## 6 2020-01-25 Orange California 06059 1 0 This is the same data that powers the NYT’s Coronavirus tracker. They have a team of reporters that update the data every day. There is a new row of data for each county, each day. The data includes the date of the update along with the county, state, a FIPS code (a special geographic designation) as well as the total cases and deaths from COVID up to that date. Since the data is cumulative, we only want the most recent date for each county. 12.4.2 Slice the most recent data Most of the concept in the next chunk you know already, but slice() is new so I’ll do this all and then explain it. Create a new section that notes you are getting the most recent Texas data by county. Add the code chunk below (one line at a time!) and run it. tx_covid &lt;- covid %&gt;% filter(state == &quot;Texas&quot;) %&gt;% group_by(county) %&gt;% slice_max(date) %&gt;% # our new function that gets the latest date filter(county != &quot;Unknown&quot;) %&gt;% select(-state) tx_covid ## # A tibble: 255 × 5 ## # Groups: county [255] ## date county fips cases deaths ## &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2022-02-25 Anderson 48001 9477 229 ## 2 2022-02-25 Andrews 48003 3785 70 ## 3 2022-02-25 Angelina 48005 15224 464 ## 4 2022-02-25 Aransas 48007 3977 77 ## 5 2022-02-25 Archer 48009 2085 28 ## 6 2022-02-25 Armstrong 48011 498 8 ## 7 2022-02-25 Atascosa 48013 13191 226 ## 8 2022-02-25 Austin 48015 5508 71 ## 9 2022-02-25 Bailey 48017 1370 38 ## 10 2022-02-25 Bandera 48019 3504 73 ## # … with 245 more rows IMPORTANT NOTE: The date values in your data should be more recent than what is shown here since you are downloading at a later date. Let’s break this down The first line creates a new R object tx_covid and fills it with the expression that follows, which is built from our raw covid data/ The next line filters for Texas. Typical stuff for us. The next challenge is to find the most recent date for each county in Texas. There will be a row for each date for each county, and we want only the most recent date for each county. So, we do this by using group_by(county)so the next action will happen within the records for each county. slice_max() is our new function, which is related to the tidyverse slice() function, which lets you “subset” rows of data based on its position in your data. The documentation includes this: “slice_min() and slice_max() select rows with highest or lowest values of a variable.” That is what we do here … we use slice_max() to get the “highest” or latest date in our data. Since this follows group_by(county), it finds the most recent date for each county. If you are running these one line at a time like I suggested, you’ll notice there are 255 returns when there are only 254 counties in Texas. That is because there is a county value of Unknown, which we filter out using a standard filter. Lastly, we use select() to remove the state column since we don’t need it anymore. So now you have the latest COVID-19 case and death counts for each county in Texas. 12.5 Get county populations using tidycensus We can’t compare the counts of each county against each other because they have differing numbers of people. Let’s put it like this using Oct. 15, 2021 numbers: Harris County – the state’s largest county – has had 569,187 cases out of 4.7 million people. Loving County – the smallest county – has only 8 cases, but that is out of a total of 64 people in the county. Which is worse? And yes, only 64 people lived in Loving County when the 2020 census was taken on April 1, 2020. So, let’s use tidycensus to get the populations. Since the 2020 Decennial “Redistricting file” was released this year, we have really fresh and accurate population numbers. 12.5.1 Find the data on data.census.gov As I said in the last chapter, the hardest part of using Census data is finding what you want. There is so much data it is hard to find or even know what you need. From experience I know that in the first Decennial Redistricting data release, there is a RACE table that has a total population for each census geography. This is the most accurate count we have of people in the U.S., but we only get it every 10 years. You are just lucky to live at this time where this data is super fresh (relatively). If you search for “Total Population” on http://data.census.gov you should get the P1 table called RACE as the first return, but if not you can click here to get directly to it. P1 table 12.5.2 Find the variable name OK, now for the fun part. We can again use load_variables(), but the program we search for is pl. UNIMPORTANT ASIDE: That is an L in “pl,” as in the PL 94-171, the law that requires the Census Bureau to produce this file. It’s kinda confusing since we are also working with the P1 (one) table. Start a new section and note you are getting the decennial population variable. Run the code below and then open the table by double-clicking table icon for that object in your Environment pane. pl_variables &lt;- load_variables(2020, &quot;pl&quot;, cache = TRUE) This is how you can open the table: Open table When we open that as a table view from your environment, we get lucky that we can see the value we are looking for: P1_001N. P1 value Note the name of the variable in your markdown so you have it handy. 12.5.3 Fetch the population data Getting data form the decennial census is similar to the ACS, just with a differently-named function: get_decennial(). You need at least the year, the variables and the geography for your return. Since it is Alabama that we see on the data.census.gov portal, we’ll start by pulling state values to make sure our numbers match. Start a subsection or otherwise note you are fetching a test of the variable. If you haven’t already, you should include a link back to your table on data.census.gov. Insert the code block below and run it. Might as well copy/paste all of it because you need all three arguments for it to work. get_decennial( year = 2020, variables = &quot;P1_001N&quot;, geography = &quot;state&quot; ) ## Getting data from the 2020 decennial Census ## Using the PL 94-171 Redistricting Data summary file ## Note: 2020 decennial Census data use differential privacy, a technique that ## introduces errors into data to preserve respondent confidentiality. ## ℹ Small counts should be interpreted with caution. ## ℹ See https://www.census.gov/library/fact-sheets/2021/protecting-the-confidentiality-of-the-2020-census-redistricting-data.html for additional guidance. ## This message is displayed once per session. ## # A tibble: 52 × 4 ## GEOID NAME variable value ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 01 Alabama P1_001N 5024279 ## 2 02 Alaska P1_001N 733391 ## 3 04 Arizona P1_001N 7151502 ## 4 05 Arkansas P1_001N 3011524 ## 5 06 California P1_001N 39538223 ## 6 08 Colorado P1_001N 5773714 ## 7 09 Connecticut P1_001N 3605944 ## 8 10 Delaware P1_001N 989948 ## 9 11 District of Columbia P1_001N 689545 ## 10 16 Idaho P1_001N 1839106 ## # … with 42 more rows Our return shows a value of 5024279 for Alabama, which matches the data portal, so we have the correct variable. Let’s keep this here just for reference. 12.5.4 Get data for Texas counties Start a new section and note you are getting the Texas county populations. Build your data using the get_decennial() as noted below. Note you need the first three arguments before it wil work at all. I’ve suppressed the output here because it doesn’t show well in the book. tx_pop &lt;- get_decennial( year = 2020, variables = &quot;P1_001N&quot;, geography = &quot;county&quot;, state = &quot;TX&quot;, geometry = TRUE ) %&gt;% clean_names() %&gt;% arrange(name) tx_pop A couple of things to note here: We set the geography argument to “county” to get county results across the U.S. We use state argument set to “TX” to get just Texas counties. We use the geometry = TRUE argument to get our shapes for mapping. We pipe the result of all that into clean_names() because some of the column names are UPPERCASE. We don’t have to do this, I’m just anal retentive. 12.6 About joins OK, before we go further we need to talk about joining data. It’s one of those Basic Data Journalism Functions … There are several types of joins. We describe these as left vs right based on which table we reference first (which is the left one). What joins do is match rows from multiple data sets that have the same “key value” and then append the data along those rows. Our two data sets have the same value in both, they just happend to be named different things. Look at these two glimpses and note the fips and geoid fields between them. tx_covid %&gt;% glimpse() ## Rows: 255 ## Columns: 5 ## Groups: county [255] ## $ date &lt;date&gt; 2022-02-25, 2022-02-25, 2022-02-25, 2022-02-25, 2022-02-25, 20… ## $ county &lt;chr&gt; &quot;Anderson&quot;, &quot;Andrews&quot;, &quot;Angelina&quot;, &quot;Aransas&quot;, &quot;Archer&quot;, &quot;Armstr… ## $ fips &lt;chr&gt; &quot;48001&quot;, &quot;48003&quot;, &quot;48005&quot;, &quot;48007&quot;, &quot;48009&quot;, &quot;48011&quot;, &quot;48013&quot;, … ## $ cases &lt;dbl&gt; 9477, 3785, 15224, 3977, 2085, 498, 13191, 5508, 1370, 3504, 21… ## $ deaths &lt;dbl&gt; 229, 70, 464, 77, 28, 8, 226, 71, 38, 73, 225, 32, 149, 852, 58… tx_pop %&gt;% glimpse() ## Rows: 254 ## Columns: 5 ## $ geoid &lt;chr&gt; &quot;48001&quot;, &quot;48003&quot;, &quot;48005&quot;, &quot;48007&quot;, &quot;48009&quot;, &quot;48011&quot;, &quot;48013&quot;… ## $ name &lt;chr&gt; &quot;Anderson County, Texas&quot;, &quot;Andrews County, Texas&quot;, &quot;Angelina … ## $ variable &lt;chr&gt; &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_00… ## $ value &lt;dbl&gt; 57922, 18610, 86395, 23830, 8560, 1848, 48981, 30167, 6904, 2… ## $ geometry &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((-96.0648 31..., MULTIPOLYGON (((… The fips and geoid columns are the same value under different names. This is the FIPS code for counties used in all kinds of government data. It’s actually a combination of the state FIPS (48 for Texas) and the county designation (the last three numbers). This creates a unique combination for every county in the U.S. Knowing we have these two similar values, we can Join the rows that have the same value in both. Basically we will add the columns of one data set to the other based on that value. In our case, we have the same 254 rows in each data set, but if we didn’t we would need to decide what to do with data that DIDN’T match. In the figure below, we can see which matching records are retained based on the type of join we use. Types of joins The join syntax works like this, with the * as the direction of the join: new_dataframe &lt;- *_join(first_df, second_df, by = field_name_to_join_on) If the fields you are joining on are not named the same thing (as in our case), then you can define the relationships: by = c(\"a\" = \"b\"). For our purposes here we want to use an inner_join(). We have to start with our population data first for the mapping to work later. (This threw me for a loop when wrote this, so learn from my experience.) We’ll then add our our covid data. 12.6.1 Join our data together Start a new section and note we are joining our data. Add the code below, run and review the results and the explanation below. tx_joined &lt;- inner_join( tx_pop, # first table tx_covid, # second table with columns we&#39;ll add by = c(&quot;geoid&quot; = &quot;fips&quot;) # note the joining columns ) tx_joined ## Simple feature collection with 254 features and 8 fields ## Geometry type: MULTIPOLYGON ## Dimension: XY ## Bounding box: xmin: -106.6456 ymin: 25.83738 xmax: -93.50829 ymax: 36.5007 ## Geodetic CRS: NAD83 ## # A tibble: 254 × 9 ## geoid name variable value geometry date county cases ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;MULTIPOLYGON [°]&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 48001 Ander… P1_001N 57922 (((-96.0648 31.98066, -9… 2022-02-25 Ander… 9477 ## 2 48003 Andre… P1_001N 18610 (((-103.0647 32.52219, -… 2022-02-25 Andre… 3785 ## 3 48005 Angel… P1_001N 86395 (((-95.00488 31.42396, -… 2022-02-25 Angel… 15224 ## 4 48007 Arans… P1_001N 23830 (((-96.8229 28.16743, -9… 2022-02-25 Arans… 3977 ## 5 48009 Arche… P1_001N 8560 (((-98.95383 33.48959, -… 2022-02-25 Archer 2085 ## 6 48011 Armst… P1_001N 1848 (((-101.6294 34.75006, -… 2022-02-25 Armst… 498 ## 7 48013 Atasc… P1_001N 48981 (((-98.80488 29.10702, -… 2022-02-25 Atasc… 13191 ## 8 48015 Austi… P1_001N 30167 (((-96.62085 30.0452, -9… 2022-02-25 Austin 5508 ## 9 48017 Baile… P1_001N 6904 (((-103.0469 33.8503, -1… 2022-02-25 Bailey 1370 ## 10 48019 Bande… P1_001N 20851 (((-99.60332 29.74026, -… 2022-02-25 Bande… 3504 ## # … with 244 more rows, and 1 more variable: deaths &lt;dbl&gt; So, to break this down: Our new combined dataframe will be called tx_joined, which is filled from the result of … We start the inner_join() and then name our two tables. Since our “key” columns don’t have the same name, we have to specify how to join them. We need to name these columns in the same order as we name the tables, hence by = c(\"fips\" = \"geoid\") Page through the result so you can see the new columns. Here is glimpse of the new table: tx_joined %&gt;% glimpse() ## Rows: 254 ## Columns: 9 ## $ geoid &lt;chr&gt; &quot;48001&quot;, &quot;48003&quot;, &quot;48005&quot;, &quot;48007&quot;, &quot;48009&quot;, &quot;48011&quot;, &quot;48013&quot;… ## $ name &lt;chr&gt; &quot;Anderson County, Texas&quot;, &quot;Andrews County, Texas&quot;, &quot;Angelina … ## $ variable &lt;chr&gt; &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_001N&quot;, &quot;P1_00… ## $ value &lt;dbl&gt; 57922, 18610, 86395, 23830, 8560, 1848, 48981, 30167, 6904, 2… ## $ geometry &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((-96.0648 31..., MULTIPOLYGON (((… ## $ date &lt;date&gt; 2022-02-25, 2022-02-25, 2022-02-25, 2022-02-25, 2022-02-25, … ## $ county &lt;chr&gt; &quot;Anderson&quot;, &quot;Andrews&quot;, &quot;Angelina&quot;, &quot;Aransas&quot;, &quot;Archer&quot;, &quot;Arms… ## $ cases &lt;dbl&gt; 9477, 3785, 15224, 3977, 2085, 498, 13191, 5508, 1370, 3504, … ## $ deaths &lt;dbl&gt; 229, 70, 464, 77, 28, 8, 226, 71, 38, 73, 225, 32, 149, 852, … Now that we have our cases, deaths and value (or population) columns in the same table so we can do some math to create case and death rates. 12.6.2 Clean up column names, etc. Let’s rename our value column to a more descriptive total_pop and remove some other unneeded columns. I don’t think we’ve renamed columns using rename() yet so we’ll do this together. Rename works similar to mutate() in that you name the new column first and then set it equal to the old one. We’re also using select() which we’ve done before. Create a new section noting you are renaming columns and other cleanup. Add this chunk and run it. tx_renamed &lt;- tx_joined %&gt;% rename( total_pop = value ) %&gt;% select(-name, -variable) tx_renamed %&gt;% glimpse() ## Rows: 254 ## Columns: 7 ## $ geoid &lt;chr&gt; &quot;48001&quot;, &quot;48003&quot;, &quot;48005&quot;, &quot;48007&quot;, &quot;48009&quot;, &quot;48011&quot;, &quot;48013… ## $ total_pop &lt;dbl&gt; 57922, 18610, 86395, 23830, 8560, 1848, 48981, 30167, 6904, … ## $ geometry &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((-96.0648 31..., MULTIPOLYGON ((… ## $ date &lt;date&gt; 2022-02-25, 2022-02-25, 2022-02-25, 2022-02-25, 2022-02-25,… ## $ county &lt;chr&gt; &quot;Anderson&quot;, &quot;Andrews&quot;, &quot;Angelina&quot;, &quot;Aransas&quot;, &quot;Archer&quot;, &quot;Arm… ## $ cases &lt;dbl&gt; 9477, 3785, 15224, 3977, 2085, 498, 13191, 5508, 1370, 3504,… ## $ deaths &lt;dbl&gt; 229, 70, 464, 77, 28, 8, 226, 71, 38, 73, 225, 32, 149, 852,… 12.7 Create our rate columns Our whole goal here was to find the number of cases per population per county and we are finally at a place where we can. We do this using mutate() and we’ve done stuff like this in the past with the Military Surplus assignment. We’re actually going to find “cases per 1,000 people” because otherwise the numbers would be too small to comprehend. For a good explanation of why we need this, read Robert Niles’ take on per capita rates. It is also covered on Page 16 of Numbers in the Newsroom by Sarah Cohen. To get a per-1,000 rate, the math works like this: (cases / (total_pop / 1000)). Start a new section noting you are creating your rates Add the chunk and run it. I’m suppressing the output here because the book doesn’t show it well. tx_rates &lt;- tx_renamed %&gt;% mutate( cases_per_pop = (cases / (total_pop / 1000)) %&gt;% round() ) tx_rates You should be able to comprehend the mutate() function by now. Go to the last column in the tibble that returns and make sure you have a new column named `cases_perpop_ and that everything worked as you expected. 12.7.1 On your own: Get a deaths rate per 1,000 Edit your rates chunk to add an additional rule to calculate deaths per 1,000 people. It’s pretty much the same but using deaths. 12.7.2 On your own: Find counties with highest rates On your own, I want you to create two lists: One of the Top 10 counties with the highest cases-per-1,000 and another of the Top 10 counties with the highest deaths-per-1,000 cases. Don’t overthink this … it is a simple arrange, select and head combination. You do not need to save these into new object … just print to the screen. Use select() to show just the county, total_pop, cases/deaths and the appropriate rate for each view. Note that the geometry column will always show. You can’t remove it … that’s just how it works. 12.8 Mapping the rates for Texas counties We’ll build a Texas map of the rates much like we did with the broadband rates in the last chapter. In fact it is pretty much the same code with updated variables and text. Create a new section that you will map cases per 1,000 Add the chunk below and run it. Update the labs to add a title, etc. tx_rates %&gt;% ggplot() + geom_sf(aes(fill = cases_per_pop), color = &quot;white&quot;, size = .2) + theme_void() + labs( title = &quot;COVID cases per 1,000 in Texas counties&quot;, caption = &quot;Source: New York Times COVID, Census Bureau/2020 Decennial&quot; ) + scale_fill_distiller( palette = &quot;Greens&quot;, direction = 1, name = &quot;Cases per 1000&quot; ) + theme(plot.margin = unit(c(10,0,10,0), &quot;pt&quot;)) 12.9 On your own: Map the deaths per 1,000 On your own, create a map like above but: Use your deaths per 1,000 data. Change the color Update the titles, etc to be correct. 12.10 What we’ve learned We learned that the New York Times is awesome that they have collected COVID data and then shared it with the world. We used group_by() and slice_max() to get the most recent data for each county. We used tidycensus to get population data and geometry data for mapping. You made more maps. 12.11 Turn in your work (There may be an extra-credit assignment that you can try if I can work it up in time. You should know by class time.) Make sure your Markdown is in good shape, chunks named, etc. Make sure everything runs and knits all the way through. Zip your project and turn it into Canvas. "],["mastery.html", "Chapter 13 Mastery - Mixed Beverages 13.1 The assignment outline 13.2 About the interviews 13.3 About the data 13.4 Story ideas 13.5 Downloading and cleaning the data 13.6 Export your data 13.7 How to tackle the analysis", " Chapter 13 Mastery - Mixed Beverages With this assignment you will be given a dataset, recorded interviews and some story ideas and you will build a full story based on the collection. 13.1 The assignment outline First, let’s talk about the deliverables: You’ll produce an 500-word data drop based on the data. This should be written as a news story like most of our other data drops. You need three or four “facts” from the data to build a good case, and then support those with quotes. Don’t pad your story with an exposé on the drinking culture in Austin, just find more data facts and quotes to build a better story. (100 points) You’ll turn in any analysis work you’ve done (your R project), regardless if it is used in the story. I want ALL of your work. (100 points) You’ll produce at least one publishable chart to go with your story using ggplot or Datawrapper. This chart needs to have a proper headline, description, legend, annotations and such so that the chart can be understood outside the context of the story. Include an image and/or link in your story. (100 points) You will be assigned an editing partner from the class to work with. You will each do your own story (and must have different angles), but the idea is you have someone to regularly talk with about your analysis, edit your story and proof-read your charts. At the end of the first week you have an assignment where you tell me your editing partner and angle they are looking at, and then another later where you discuss how you helped each other. 13.2 About the interviews I have two recorded interviews for you to work from, and the links are in Canvas on the main assignment called “Mixed Beverage project.” Both interviews include discussion of alcohol sales, including dealing with the pandemic. When these were recorded in spring 2021 we were also using TABC violations data, so the interviews also cover selling to minors and such. Those parts aren’t really germane to this assignment, but there is plenty to draw from. Andy Kahn is a bartender at The Mockingbird near campus. He worked previously as a manager at The Hole in the Wall. Chad Womack is the owner of The Dogwood, which has locations on W. 6th and in The Domain (as well as other cities). He co-owns them with his brother Brad (yes, that Brad Womack) and Jason Carrier through Carmack Concepts. It is worth going through the interviews early on so you can tailor your analysis around what they talk about. 13.3 About the data You’ll be drawing from at least five years of data from the Mixed Beverage Gross Receipts for locations with an Austin local address. You should take a look at that page while you familiarize yourself with the data, which also serves as your data dictionary. Each month, every Texas establishment that sells liquor-by-the-drink (restaurants, bars, stadiums, etc) has to report their sales to the state for tax purposes. 13.3.1 Important things to know Each row of the data is the amount of total money brought in each month by an establishment, based on the Obligation End Date, which is always the last day of the reporting month. This means you can see trends by month, but not any time period smaller than that. There are four values of money reported: Total Receipts, Wine Receipts, Beer Receipts, Liquor Receipts and Cover Charge Receipts. The beer, wine, liquor and cover charge values should add up to the Total Receipts, though I’ve found that is not always true. I would stay away from any analysis on Cover Charges as there must be some special rules of when they need to be reported that would need investigation to understand. The amounts are sales amounts (i.e., total amount of money bought in for that month for that category) and not profits or number of drinks sold. Some other things to know: Sometimes names of taxpayers and locations are obscured. Hotel chains may have a company that serves all their hotels. A beverage company may hold license to sell in multiple locations. It is important to group by both Location Name AND Location Address to find specific locations. You can google the address to find out the real name of an establishment. Also be aware that some companies have more than one location with the same name, so again you should group by both Location Name and Location Address to get totals specific locations. Each Taxpayer Name has only one Taxpayer Number, but that company could own many establishments in many locations. For the most part we can ignore Responsibility Begin and End dates if you always group by Location Name and Location Address when looking at single locations. This is used when an establishment changes hands and has different owners within the same month. 13.4 Story ideas Here is a list of questions you could ask that can lead to story ideas. Which establishments have sold the most alcohol over the past five years? How does that look on a monthly basis? (Be sure to watch for multiple locations of the same name and name changes of the same location.) Perhaps take the same idea but for a smaller geographic area. The Drag (Guadalupe between 19th and 30th). West Campus (78705). The Domain area (78758). Downtown (78701). South Austin (78704). East Austin (78702) and north of there (78722). One thing to be aware of here is that ZIPs cross over city boundaries You could compare sales between popular areas. Or sales over time in a certain area. How did COVID-19 affect sales in 2020 and how are they rebounding in 2021? Is the number of restaurants or bars growing in certain areas? Like in east or south Austin? Again, ZIP codes might be a good geography to hone in on. How do sales break down by alcohol type? Who sold the most beer last year? Wine? Again, could break down by geography. How do sales change over the seasons around West Campus? What do establishments do to deal with that? How much does March mean to sales of alcohol downtown during SXSW? (Like what percentage of their yearly sales?) What was the difference in 2020 and 2021 compared to 2019? What owner/company has sold the most alcohol? (Taxpayer name). Or who owns the most locations in the city? There are certainly other ideas, but key are the fact you have date ranges, some geographic locations like addresses and ZIP codes and the beer/wine/liquor/total sales values to work from. 13.5 Downloading and cleaning the data We’ll get our data directly from the data.texas.gov portal using the Socrata API. You’ll need to install the RSocrata package first, but you don’t need an API key for this. Go ahead and set up a new project. You’ll have a separate import-cleaning notebook from your analysis notebook. Use good naming practices. Install the RSocrata package in your console: install.packages(\"RSocrata\"). You’ll need the following libraries: library(tidyverse) library(janitor) library(RSocrata) 13.5.1 Set up the download url The key to using RSocrata and the Socrata API is to build a URL that will get us the data we want. I figured this out by reading through their documentation but that is beyond the scope of this lesson. But I will explain it, more or less. For this first part we are just building a flexible way to filter our data before downloading. I’ll explain below. mixbev_base_url = &#39;https://data.texas.gov/resource/fp9t-htqh.json?&#39; start_date = &#39;2016-01-31&#39; end_date = &#39;2021-08-31&#39; city = &#39;AUSTIN&#39; download_url &lt;- paste( mixbev_base_url, &quot;$limit=100&amp;&quot;, # comment out this line in your notebook &quot;$where=obligation_end_date_yyyymmdd%20between%20&quot;, &quot;&#39;&quot;, start_date, &quot;&#39;&quot;, &quot; and &quot;, &quot;&#39;&quot;, end_date, &quot;&#39;&quot;, &quot;&amp;location_city=&quot;, &quot;&#39;&quot;, city, &quot;&#39;&quot;, sep = &quot;&quot; ) download_url ## [1] &quot;https://data.texas.gov/resource/fp9t-htqh.json?$limit=100&amp;$where=obligation_end_date_yyyymmdd%20between%20&#39;2016-01-31&#39; and &#39;2021-08-31&#39;&amp;location_city=&#39;AUSTIN&#39;&quot; The first several lines are creating variables for the base URL and dates ranges for the data. If we wanted data from a different date range or city, we could change those. It just provides flexibility and ease for updates. One thing about those dates: We are filtering the data to include five full years plus valid months in 2021. Since reporting lags on this by as much as two months, we don’t have full reports for September or October 2021 so we are excluding them. The download_url object pieces together the parts of the url that we need to download the data. This url is an “endpoint” for the Socrata API for this dataset. It uses SoQL queries to select only the data we want. The paste() function is just putting together the pieces of the URL endpoint based on our variables. I print it out at the end so you can see what the finished URL looks like. You could copy/paste that endpoint (between the ““) into a browser to see what the data looks like. I have a limit line in here for testing. I just pull 1000 lines of the data instead of all of them. You need to comment out this line in your notebook to get all the data. REALLY, REALLY IMPORTANT NOTE: Hey, did you see that note about the \"$limit=100&amp;\" line? You must comment out the limit to get all the data you need. This example above could be repurposed to pull data from a different dataset on any agency’s Socrata platform. 13.5.2 Download the data Now that we have the url we can download the data into an R object. This can take 30 seconds or more as it a decent amount of data, about 75k rows. (Though I only show 100 here. Remember to comment that limit line out when you are ready to pull all of the data). receipts_api &lt;- read.socrata(download_url) # look at the data receipts_api %&gt;% glimpse() ## Rows: 100 ## Columns: 24 ## $ taxpayer_number &lt;chr&gt; &quot;32039395531&quot;, &quot;12630963622&quot;, &quot;174… ## $ taxpayer_name &lt;chr&gt; &quot;CORNER WEST, LLC&quot;, &quot;MAC ACQUISITI… ## $ taxpayer_address &lt;chr&gt; &quot;715 W 6TH ST&quot;, &quot;1855 BLAKE ST STE… ## $ taxpayer_city &lt;chr&gt; &quot;AUSTIN&quot;, &quot;DENVER&quot;, &quot;MERRILLVILLE&quot;… ## $ taxpayer_state &lt;chr&gt; &quot;TX&quot;, &quot;CO&quot;, &quot;IN&quot;, &quot;FL&quot;, &quot;TX&quot;, &quot;TX&quot;… ## $ taxpayer_zip &lt;chr&gt; &quot;78701&quot;, &quot;80202&quot;, &quot;46410&quot;, &quot;32837&quot;… ## $ taxpayer_county &lt;chr&gt; &quot;227&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;227&quot;, &quot;227&quot;… ## $ location_number &lt;chr&gt; &quot;1&quot;, &quot;7&quot;, &quot;39&quot;, &quot;5&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;… ## $ location_name &lt;chr&gt; &quot;THE DOGWOOD&quot;, &quot;ROMANO&#39;S MACARONI … ## $ location_address &lt;chr&gt; &quot;715 W 6TH ST&quot;, &quot;701 E STASSNEY LN… ## $ location_city &lt;chr&gt; &quot;AUSTIN&quot;, &quot;AUSTIN&quot;, &quot;AUSTIN&quot;, &quot;AUS… ## $ location_state &lt;chr&gt; &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;… ## $ location_zip &lt;chr&gt; &quot;78701&quot;, &quot;78745&quot;, &quot;78701&quot;, &quot;78758&quot;… ## $ location_county &lt;chr&gt; &quot;227&quot;, &quot;227&quot;, &quot;227&quot;, &quot;227&quot;, &quot;227&quot;,… ## $ inside_outside_city_limits_code_y_n &lt;chr&gt; &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;,… ## $ tabc_permit_number &lt;chr&gt; &quot;MB750447&quot;, &quot;MB710753&quot;, &quot;MB913070&quot;… ## $ responsibility_begin_date_yyyymmdd &lt;dttm&gt; 2010-06-15, 2008-12-18, 2015-07-0… ## $ obligation_end_date_yyyymmdd &lt;dttm&gt; 2016-04-30, 2016-10-31, 2018-02-2… ## $ liquor_receipts &lt;chr&gt; &quot;237013&quot;, &quot;2658&quot;, &quot;63669&quot;, &quot;73418&quot;… ## $ wine_receipts &lt;chr&gt; &quot;5497&quot;, &quot;8537&quot;, &quot;41558&quot;, &quot;20379&quot;, … ## $ beer_receipts &lt;chr&gt; &quot;83765&quot;, &quot;1309&quot;, &quot;20078&quot;, &quot;105510&quot;… ## $ cover_charge_receipts &lt;chr&gt; &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;,… ## $ total_receipts &lt;chr&gt; &quot;326275&quot;, &quot;12504&quot;, &quot;125305&quot;, &quot;1993… ## $ responsibility_end_date_yyyymmdd &lt;dttm&gt; NA, 2018-02-14, NA, NA, NA, NA, N… 13.5.3 Fix some values If you look at the data types of these columns you’ll find that the _receipts columns are &lt;chr&gt; (which means characters) instead of &lt;dbl&gt; (which is numbers). We can’t do math with text, so we need to fix that. I’m going to give you an assist here because I found a pretty cool way to do this that I want to share. Tidyverse has a function called type_convert() that helps change between text and number data types and it can help us here. It allows us to specify data types for specific columns. Start a new section and note you are fixing the receipts columns. Add this code block and run it. receipts_converted &lt;- receipts_api %&gt;% type_convert( cols( .default = col_character(), # sets a default of character unless specified below liquor_receipts = col_double(), wine_receipts = col_double(), beer_receipts = col_double(), cover_charge_receipts = col_double(), total_receipts = col_double() ) ) receipts_converted %&gt;% glimpse() ## Rows: 100 ## Columns: 24 ## $ taxpayer_number &lt;chr&gt; &quot;32039395531&quot;, &quot;12630963622&quot;, &quot;174… ## $ taxpayer_name &lt;chr&gt; &quot;CORNER WEST, LLC&quot;, &quot;MAC ACQUISITI… ## $ taxpayer_address &lt;chr&gt; &quot;715 W 6TH ST&quot;, &quot;1855 BLAKE ST STE… ## $ taxpayer_city &lt;chr&gt; &quot;AUSTIN&quot;, &quot;DENVER&quot;, &quot;MERRILLVILLE&quot;… ## $ taxpayer_state &lt;chr&gt; &quot;TX&quot;, &quot;CO&quot;, &quot;IN&quot;, &quot;FL&quot;, &quot;TX&quot;, &quot;TX&quot;… ## $ taxpayer_zip &lt;chr&gt; &quot;78701&quot;, &quot;80202&quot;, &quot;46410&quot;, &quot;32837&quot;… ## $ taxpayer_county &lt;chr&gt; &quot;227&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;227&quot;, &quot;227&quot;… ## $ location_number &lt;chr&gt; &quot;1&quot;, &quot;7&quot;, &quot;39&quot;, &quot;5&quot;, &quot;3&quot;, &quot;3&quot;, &quot;2&quot;… ## $ location_name &lt;chr&gt; &quot;THE DOGWOOD&quot;, &quot;ROMANO&#39;S MACARONI … ## $ location_address &lt;chr&gt; &quot;715 W 6TH ST&quot;, &quot;701 E STASSNEY LN… ## $ location_city &lt;chr&gt; &quot;AUSTIN&quot;, &quot;AUSTIN&quot;, &quot;AUSTIN&quot;, &quot;AUS… ## $ location_state &lt;chr&gt; &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;, &quot;TX&quot;… ## $ location_zip &lt;chr&gt; &quot;78701&quot;, &quot;78745&quot;, &quot;78701&quot;, &quot;78758&quot;… ## $ location_county &lt;chr&gt; &quot;227&quot;, &quot;227&quot;, &quot;227&quot;, &quot;227&quot;, &quot;227&quot;,… ## $ inside_outside_city_limits_code_y_n &lt;chr&gt; &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;,… ## $ tabc_permit_number &lt;chr&gt; &quot;MB750447&quot;, &quot;MB710753&quot;, &quot;MB913070&quot;… ## $ responsibility_begin_date_yyyymmdd &lt;dttm&gt; 2010-06-15, 2008-12-18, 2015-07-0… ## $ obligation_end_date_yyyymmdd &lt;dttm&gt; 2016-04-30, 2016-10-31, 2018-02-2… ## $ liquor_receipts &lt;dbl&gt; 237013, 2658, 63669, 73418, 203774… ## $ wine_receipts &lt;dbl&gt; 5497, 8537, 41558, 20379, 6527, 26… ## $ beer_receipts &lt;dbl&gt; 83765, 1309, 20078, 105510, 21446,… ## $ cover_charge_receipts &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ total_receipts &lt;dbl&gt; 326275, 12504, 125305, 199307, 231… ## $ responsibility_end_date_yyyymmdd &lt;dttm&gt; NA, 2018-02-14, NA, NA, NA, NA, N… Let’s break this down We start with a new R Object to fill (and a glimpse of it at the end). We take receipts_api and pipe into type_convert() and specify the cols() function there. The first line inside cols is .default = col_character() which tells type_convert to only change columns we specify after it. If we didn’t include this then the *_zip and *_county columns would be converted to numbers and we don’t want that. Especially the ZIP code, because that is NOT a number. The rest of the lines set the receipts columns to col_double() to make them numbers. We could’ve done this using mutate() with as.numeric() and overwriting the columns, but I like this method and wanted to show it to you. 13.6 Export your data This tibble receipts_converted is ready to be exported as an .rds file to use in your analysis notebook. I’ll leave that up to you ;-). 13.7 How to tackle the analysis The specifics will depend on what you are trying to learn from the data, but check out the next chapter “How to interview your data” for some general tips and concept reviews. "],["how-to-interview-a-new-dataset.html", "Chapter 14 How to interview a new dataset 14.1 Start by listing questions 14.2 Understand your data 14.3 Pay attention to the shape of your data 14.4 Counting and aggregation 14.5 Cleaning up categorical data 14.6 Time as a variable 14.7 Explore the distributions in your data 14.8 Same ideas using spreadsheets", " Chapter 14 How to interview a new dataset For those unfamiliar with exploring data, starting the process can be paralyzing. How do I explore when I don’t know what I’m looking for? Where do I start? Every situation is different, but there are some common techniques and some common sense that you can bring to every project. 14.1 Start by listing questions It’s likely you’ve acquired data because you needed it to add context to a story or situation. Spend a little time at the beginning brainstorming as list of questions you want to answer. (You might ask a colleague to participate: the act of describing the data set will reveal questions for both of you.) I like to start my RNotebook with this list. 14.2 Understand your data Before you start working on your data, make sure you understand what all the columns and values mean. Look at your data dictionary, or talk to the data owner to make sure you understand what you are working with. To get a quick summary of all the values, you can use a function called summary() to give you some basic stats for all your data. Here is an example from the Billboard Hot 100 data we used in a class assignment. Summary of billboard data A summary() will show you the data type for each column, and then for number values it will show you the min, max, median, mean and other stats. 14.3 Pay attention to the shape of your data Is your data long or wide? Wide data adds new observations as columns, with the headers describing the observation. Official reports and Excel files from agencies are often in this format: Country 2018 2017 United States 20,494,050 19,390,604 China 13,407,398 12,237,700 Long data is where each row in the data is a single observation, and each column is an attribute that describes that observation. Data-centric languages and applications like R and Tableau typically prefer this format. Country Year GDP United States 2018 20,494,050 United States 2017 19,390,604 China 2018 13,407,398 China 2017 12,237,700 The shape of the data will determine how you go about analyzing it. They are both useful in different ways. Wide data allows you to calculate columns to show changes. Visualization programs will sometimes want a long format to more easily categorize values based on the attributes. You can pivot your data with pivot_longer() and pivot_wider to change the shape of your data. 14.4 Counting and aggregation A large part of data analysis is counting and sorting, or filtering and then counting and sorting. Depending on the program you are using you may approach it differently but think of these concepts: 14.4.1 Counting rows based on a column If you are just counting the number of rows based on the values within a column (or columns), then count() is the key. When you use count() like this, a new column called n is created to hold the count of the rows. You can rename n with the name = \"new_name\" argument, and you can change the sorting to descending order using the sort = TRUE argument. In this example, we are counting the number of rows for each princess in our survey data, the arranging them in descending order. survey %&gt;% count(princess, name = &quot;votes&quot;, sort = TRUE) princess votes Mulan 14 Rapunzel (Tangled) 7 Jasmine (Aladdin) 6 Ariel (Little Mermaid) 5 Tiana (Princess and the Frog) 2 Aurora (Sleeping Beauty) 1 Belle (Beauty and the Beast) 1 Merida (Brave) 1 Snow White 1 14.4.2 Sum, mean and other aggregations If you want to aggregate values in a column, like adding together values, or to find a mean or median, then you will want to use the GSA combination: group_by() on your columns of interest, then use summarize() to aggregate the data in the manner you choose, like sum(), mean() or the number of rows n(). You can then use arrange() to order the result however you want. Here is an example where we use group_by and summarize() to add together values in our mixed beverage data. In this case, we had multiple rows for each name/address group, but we wanted to add together total_receipts() for each group. receipts %&gt;% group_by(location_name, location_address) %&gt;% summarize( total_sales = sum(total_receipts) ) %&gt;% arrange(desc(total_sales)) location_name location_address total_sales WLS BEVERAGE CO 110 E 2ND ST 35878211 RYAN SANDERS SPORTS 9201 CIRCUIT OF THE AMERICAS BLVD 20714630 W HOTEL AUSTIN 200 LAVACA ST 15435458 ROSE ROOM/ 77 DEGREE 11500 ROCK ROSE AVE 14726420 THE DOGWOOD DOMAIN 11420 ROCK ROSE AVE STE 700 14231072 The result will have all the columns you included in the group, plus the columns you create in your summarize statement. You can summarize more than one thing at a time, like the number of rows numb_rows = n() and average of the values average = mean(column_name). 14.4.3 Creating columns to show difference Sometimes you need to perform math on two columns to show the difference between them. Use mutate() to create the column and do the math. Here’s a pseudo-code example: new_or_reassigned_df &lt;- df %&gt;% mutate( new_col_name = (part_col / total_col) * 100 ) 14.5 Cleaning up categorical data If you are going to count our summarize rows based on categorical data, you should make sure the values in that column are clean and free of typos and values that might better be combined. Some strategies you might use: Create a count() of the column to show all the different values and how often they show up. You might want to use mutate() to create a new column and then update the values there. Or you might use recode() the set specific values to new values. If you find you have hundreds of values to clean, then come see me. There are some other tools like OpenRefine that you can learn fairly quickly to help. 14.6 Time as a variable If you have dates in your data, then you almost always want to see change over time for different variables. Summarize records by year or month as appropriate and create a Bar or Column chart to show how the number of records for each time period. Do you need to see how different categories of data have changed over time? Consider a line chart that shows those categories in different colors. If you have the same value for different time periods, do might want to see the change or percent change in those values. You can create a new column using mutate() to do the math and show the difference. 14.7 Explore the distributions in your data We didn’t talk about histograms in class, but sometimes you might want see the “distribution” of values in your data, i.e. how the values vary within the column. Are many of the values similar? A histogram can show this. Here is an example of a histogram use wells data exploring the borehole_depth (how deep the well is). Each bar represents the number of wells broken down in 100ft depth increments (set with binwidth=100). So the first bar shows that most of the wells (more than 7000) are less than 100 feet deep. wells %&gt;% ggplot(aes(x = borehole_depth)) + geom_histogram(binwidth = 100) Borehole depth histogram While there are wells deeper than 1000 feet, they are so few they don’t even show on the graphic. You’ll rarely use a histogram as a graphic with a story because they are more difficult to explain to readers. But they do help you to understand how much values differ within a column. 14.7.1 More on histograms If you google around, you might see other ways to create a histogram, including hist() and qplot(). You might stick with the ggplot’s geom_histogram() since you already are familiar with the syntax. Tutorial on histograms using ggplot from DataCamp. R Cookbook on histograms. 14.8 Same ideas using spreadsheets Check out this resource by David Eads on the same topic, with some more specifics about Google Sheets. "],["verbs.html", "Chapter 15 Verbs 15.1 Import/Export 15.2 Data manipulation 15.3 Aggregation 15.4 Math", " Chapter 15 Verbs An opinionated list of the most common Tidyverse and other R verbs used with data storytelling. 15.1 Import/Export read_csv() imports data from a CSV file. (It handles data types better than the base R read.csv()). Also write_csv() when you need export as CSV. Example: read_csv(\"path/to/file.csv\"). write_rds to save a data frame as an .rds R data data file. This preserves all the data types. read_rds() to import R data. Example: read_rds(\"path/to/file.rds\"). readxl is a package we didn’t talk about, but it has read_excel() that allows you to import from an Excel file, including specified sheets and ranges. clean_names() from the library(janitor) package standardizes column names. 15.2 Data manipulation select() to select columns. Example: select(col01, col02) or select(-excluded_col). rename() to rename a column. Example: rename(new_name = old_name). filter() to filter rows of data. Example: filter(column_name == \"value\"). See Relational Operators like ==, &gt;, &gt;= etc. See Logical operators like &amp;, | etc. See is.na tests if a value is missing. distinct() will filter rows down to the unique values of the columns given. arrange() sorts data based on values in a column. Use desc() to reverse the order. Example: arrange(col_name %&gt;% desc()) mutate() changes and existing column or creates a new one. Example: mutate(new_col = (col01 / col02)). pivot_longer() “lengthens” data, increasing the number of rows and decreasing the number of columns. Example: pivot_longer(cols = 3:5, names_to = \"new_key_col_name\", values_to = \"new_val_col_name\") will take the third through the fifth columns and turn each value into a new row of data. It will put them into two columns: The first column will have the name you give it in names_to and contain the old column name that corresponds to each value pivoted. The second column will have the name of whatever you set in values_to and will contain all the values from each of the columns. pivot_wider() is the opposite of pivot_longer(). Example: pivot_wider(names_from = col_of_key_values, values_from = col_with_values). See the link. 15.3 Aggregation count() will count the number rows based on columns you feed it. group_by() and summarize() often come together. When you use group_by(), every function after it is broken down by that grouping. Example: group_by(song, artist) %&gt;% summarize(weeks = n(), top_chart_position = min(peak_position)) 15.4 Math These are the function often used within summarize(): n() to count the number of rows. n_distinct() counts the unique values. sum() to add things together. mean() to get an average. median() to get the median. min() to get the smallest value. max() for the largest. +, -, *, / are math operators similar to a calculator. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
